{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"py-ds-academy","text":"<p>Data structures implemented from scratch for learning and experimentation</p>"},{"location":"#about","title":"\ud83c\udfaf About","text":"<p>py-ds-academy is a comprehensive collection of classic data structures implemented from scratch in Python. The goal is learning + correctness (with tests), not squeezing out every last micro-optimization.</p> <p>This project serves as both a learning resource and a reference implementation for common data structures used in computer science and software engineering.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83e\uddf1 Core Data Structures - Stacks, queues, linked lists, trees, and heaps</li> <li>\ud83d\udcdd Type Hints - Full type annotations for better code clarity</li> <li>\ud83e\uddea Comprehensive Tests - TDD-first approach with pytest</li> <li>\ud83d\udcda Well Documented - Clear APIs with complexity notes</li> <li>\ud83c\udf93 Educational - Perfect for learning data structures</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Install the package using pip or uv. See the Installation Guide for detailed instructions.</p> <pre><code>&gt;&gt;&gt; from py_ds import Stack, Queue, MinHeap, BinarySearchTree\n\n&gt;&gt;&gt; # Stack example\n&gt;&gt;&gt; s = Stack([1, 2, 3])\n&gt;&gt;&gt; s.pop()\n3\n\n&gt;&gt;&gt; # Queue example\n&gt;&gt;&gt; q = Queue([1, 2, 3])\n&gt;&gt;&gt; q.dequeue()\n1\n\n&gt;&gt;&gt; # Heap example\n&gt;&gt;&gt; h = MinHeap([3, 1, 4, 1, 5])\n&gt;&gt;&gt; h.pop()\n1\n</code></pre>"},{"location":"#implemented-data-structures","title":"\ud83d\udce6 Implemented Data Structures","text":""},{"location":"#linear-structures","title":"Linear Structures","text":"<ul> <li>\u2705 Stack - LIFO stack with list backing</li> <li>\u2705 Queue - FIFO queue with list backing</li> <li>\u2705 LinkedList - Single-direction linked list</li> <li>\u2705 DoublyLinkedList - Double-direction linked list</li> </ul>"},{"location":"#trees","title":"Trees","text":"<ul> <li>\u2705 BinaryTree - Generic binary tree with multiple traversal methods</li> <li>\u2705 BinarySearchTree - Binary search tree with insert, remove, search</li> <li>\u2705 AVLTree - Self-balancing binary search tree</li> </ul>"},{"location":"#heaps","title":"Heaps","text":"<ul> <li>\u2705 MinHeap - Minimum binary heap</li> <li>\u2705 MaxHeap - Maximum binary heap</li> </ul>"},{"location":"#learning-resources","title":"\ud83c\udf93 Learning Resources","text":"<p>This project is designed to help you:</p> <ul> <li>Understand how data structures work under the hood</li> <li>Learn time and space complexity analysis</li> <li>Practice clean code and type hints</li> <li>See real-world implementations with tests</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Explore the documentation to learn more:</p> <ul> <li>Getting Started - Installation and setup</li> <li>Data Structures - Overview of all implemented structures</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! See the Contributing Guide for details.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p> <p>Made with \u2764\ufe0f by Eytan Ohana</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to py-ds-academy! This document provides guidelines and instructions for contributing.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#fork-and-clone-the-repository","title":"Fork and Clone the Repository","text":"<ol> <li>Fork the repository on GitHub by clicking the \"Fork\" button</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/py-ds-academy.git\n\ncd py-ds-academy\n</code></pre></li> </ol>"},{"location":"contributing/#set-up-the-development-environment","title":"Set Up the Development Environment","text":""},{"location":"contributing/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>uv is a fast Python package installer and resolver written in Rust.</p> <p>Install uv:</p> <p>Follow the steps in uv's installation guide for your OS.</p> <p>Set up the project: <pre><code># Create the venv and install dependencies (including dev and doc dependencies)\nuv sync --all-groups\n\n# Install pre-commit hooks (required before development)\npre-commit install\n</code></pre></p> <p>When you install with <code>--all-groups</code>, you get:</p> <ul> <li><code>pytest</code> - Testing framework</li> <li><code>ruff</code> - Linting and formatting</li> <li><code>pre-commit</code> - Git hooks for code quality</li> <li><code>mkdocs-material</code> - Documentation generation</li> </ul>"},{"location":"contributing/#verify-development-setup","title":"Verify Development Setup","text":"<pre><code># Run tests\npytest\n\n# Run linting\nruff check .\n\n# Try importing\npython -c \"from py_ds import Stack, Queue, LinkedList; print('Development setup successful!')\"\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a new branch for your changes:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes following the project's coding standards</p> </li> <li> <p>Write or update tests for your changes</p> </li> <li> <p>Ensure all tests pass: <pre><code>pytest\n</code></pre></p> </li> <li> <p>Run linting and formatting: <pre><code>ruff check .  # or `ruff check --fix .` for fixable lint errors\nruff format .\n</code></pre></p> </li> <li> <p>Commit your changes with clear commit messages</p> </li> <li> <p>Push to your fork and create a Pull Request</p> </li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>All code should include type hints:</p> <pre><code>def push(self, item: int) -&gt; None:\n    \"\"\"Push an item onto the stack.\"\"\"\n    ...\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def pop(self) -&gt; int:\n    \"\"\"Pop and return the top item.\n\n    Returns:\n        The top item from the stack.\n\n    Raises:\n        IndexError: If the stack is empty.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use <code>ruff</code> for linting and formatting</li> <li>Maximum line length: 120 characters</li> <li>Use single quotes for strings</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new functionality</li> <li>Aim for high test coverage</li> <li>Use descriptive test names</li> <li>Follow the existing test structure</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>py-ds-academy/\n\u251c\u2500\u2500 src/py_ds/          # Source code\n\u251c\u2500\u2500 tests/              # Test files\n\u251c\u2500\u2500 docs/               # Documentation\n\u2514\u2500\u2500 pyproject.toml      # Project configuration\n</code></pre>"},{"location":"contributing/#adding-a-new-data-structure","title":"Adding a New Data Structure","text":"<ol> <li>Create the implementation in <code>src/py_ds/datastructures/</code></li> <li>Add exports to <code>src/py_ds/__init__.py</code></li> <li>Write comprehensive tests in <code>tests/</code></li> <li>Add documentation in <code>docs/structures/</code></li> <li>Update <code>docs/structures.md</code> overview</li> <li>add api reference in <code>docs/reference/</code></li> <li>add documentation in <code>docs/reference/api.md</code></li> <li>Update the README if needed</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#updating-documentation","title":"Updating Documentation","text":"<p>When updating documentation, you may need to update multiple files:</p> <ol> <li>Update the relevant documentation file in <code>docs/</code>:</li> <li>Structure guides: <code>docs/structures/</code></li> <li>Reference docs: <code>docs/reference/</code></li> <li> <p>Getting started: <code>docs/getting-started/</code></p> </li> <li> <p>Update <code>mkdocs.yml</code> if you:</p> </li> <li>Add a new documentation page</li> <li>Rename or move a documentation file</li> <li>Change the navigation structure</li> </ol> <p>The <code>mkdocs.yml</code> file controls the site navigation. Make sure your new or updated pages are included in the <code>nav</code> section with the correct path.</p> <p>Example: If you add a new file <code>docs/structures/new-structure.md</code>, add it to the navigation:    <pre><code>nav:\n  - Data Structures:\n      - Overview: structures.md\n      - New Structure: structures/new-structure.md\n</code></pre></p> <ol> <li>Update API reference if you:</li> <li>Add new classes or methods</li> <li>Change method signatures</li> <li>Add new modules</li> </ol> <p>API reference pages use <code>mkdocstrings</code> to auto-generate from docstrings. Ensure your docstrings are properly formatted.</p>"},{"location":"contributing/#documentation-guidelines","title":"Documentation Guidelines","text":"<ul> <li>Keep documentation up to date with code changes</li> <li>Add examples for new features</li> <li>Update API reference when adding new methods</li> <li>Use clear, concise language</li> <li>Test code examples to ensure they work</li> </ul>"},{"location":"contributing/#previewing-documentation","title":"Previewing Documentation","text":"<p>To preview your documentation changes locally:</p> <pre><code># Serve the documentation site locally\nmkdocs serve\n</code></pre> <p>Visit <code>http://127.0.0.1:8000/py-ds-academy/</code> to view the site.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your PR addresses a specific issue or adds a feature</li> <li>Include tests for new functionality</li> <li>Update documentation as needed (including <code>mkdocs.yml</code> if navigation changes)</li> <li>Ensure all CI checks pass</li> <li>Request review from maintainers</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions or need help, please:</p> <ul> <li>Open an issue on GitHub</li> <li>Check existing issues and discussions</li> <li>Review the documentation</li> </ul> <p>Thank you for contributing! \ud83c\udf89</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip (Python's package installer)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The easiest way to install py-ds-academy is using pip:</p> <pre><code>pip install py-ds-academy\n</code></pre>"},{"location":"getting-started/installation/#using-a-virtual-environment-recommended","title":"Using a Virtual Environment (Recommended)","text":"<p>Virtual environments help keep your project isolated and avoid conflicts with other packages installed on your system:</p> <pre><code># Create a virtual environment\npython -m venv venv\n\n# Activate it\nsource venv/bin/activate\n\n# Install py-ds-academy\npip install py-ds-academy\n</code></pre>"},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<p>uv is a fast Python package installer and resolver written in Rust. It's great for both installing packages and managing development environments.</p> <p>Install uv:</p> <p>Follow the steps in uv's installation guide for your OS.</p> <p>Install py-ds-academy:</p> <pre><code># Create a new project managed by uv\nuv init my-project\n\n# Enter your project directory\ncd my-project\n\n# Install the package\nuv add py-ds-academy\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import py_ds\n\nprint(py_ds.__version__)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Quick Start Guide to begin using the library</li> <li>Explore the Data Structures Overview</li> <li>Check out the API Reference</li> </ul>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to the project or work with the source code, see the Contributing Guide for instructions on setting up a development environment.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with py-ds-academy in minutes!</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#stack","title":"Stack","text":"<p>A Last-In-First-Out (LIFO) data structure:</p> <pre><code>from py_ds import Stack\n\n# Create a stack\nstack = Stack([1, 2, 3])\n\n# Push an item\nstack.push(4)\n\n# Pop an item (removes and returns the last item)\nitem = stack.pop()  # Returns 4\n\n# Peek at the top without removing\ntop = stack.peek()  # Returns 3\n\n# Check if empty\nis_empty = stack.is_empty()  # False\n\n# Get length\nlength = len(stack)  # 3\n</code></pre>"},{"location":"getting-started/quickstart/#queue","title":"Queue","text":"<p>A First-In-First-Out (FIFO) data structure:</p> <pre><code>from py_ds import Queue\n\n# Create a queue\nqueue = Queue([1, 2, 3])\n\n# Enqueue an item\nqueue.enqueue(4)\n\n# Dequeue an item (removes and returns the first item)\nitem = queue.dequeue()  # Returns 1\n\n# Peek at the front without removing\nfront = queue.peek()  # Returns 2\n\n# Iterate over items\nfor item in queue:\n    print(item)  # Prints 2, 3, 4\n</code></pre>"},{"location":"getting-started/quickstart/#linked-lists","title":"Linked Lists","text":"<p>Dynamic data structures for efficient insertion and deletion:</p> <pre><code>from py_ds import LinkedList, DoublyLinkedList\n\n# Linked list\nsll = LinkedList([1, 2, 3])\nsll.append(4)  # O(1) operation\nsll.prepend(0)  # O(1) operation\nprint(list(sll))  # [0, 1, 2, 3, 4]\nprint(sll)  # HEAD \u2192 0 \u2192 1 \u2192 2 \u2192 3 \u2192 4 \u2192 TAIL\n\n# Doubly linked list (supports reverse iteration / more efficient append/prepend)\ndll = DoublyLinkedList([1, 2, 3])\ndll.append(4)  # O(1) operation\ndll.prepend(0)  # O(1) operation\nprint(list(dll))  # [0, 1, 2, 3, 4]\nprint(dll)  # HEAD \u21c6 0 \u21c6 1 \u21c6 2 \u21c6 3 \u21c6 4 \u21c6 TAIL\n\n# Reverse iteration (doubly linked only)\nfor item in dll.reverse_iter():\n    print(item)  # Prints 4, 3, 2, 1, 0\n</code></pre>"},{"location":"getting-started/quickstart/#heaps","title":"Heaps","text":"<p>Priority queue implementations:</p> <pre><code>from py_ds import MinHeap, MaxHeap\n\n# Min heap (smallest element at top)\nmin_heap = MinHeap([3, 1, 4, 1, 5])\nmin_heap.push(2)\nsmallest = min_heap.pop()  # Returns 1\nprint(min_heap.peek())  # Returns 1 (next smallest)\n\n# Max heap (largest element at top)\nmax_heap = MaxHeap([3, 1, 4, 1, 5])\nmax_heap.push(10)\nlargest = max_heap.pop()  # Returns 10\nprint(max_heap.peek())  # Returns 5 (next largest)\n</code></pre>"},{"location":"getting-started/quickstart/#binary-search-tree","title":"Binary Search Tree","text":"<p>Efficient searching and sorting:</p> <pre><code>from py_ds import BinarySearchTree\n\n# Create a BST\nbst = BinarySearchTree([5, 3, 7, 2, 4, 6, 8])\n\n# Print the tree structure (visual representation)\nprint(bst)\n# Output:\n#      \u250c\u2500\u2500 8\n#  \u250c\u2500\u2500 7\n#  \u2502   \u2514\u2500\u2500 6\n#  5\n#  \u2502   \u250c\u2500\u2500 4\n#  \u2514\u2500\u2500 3\n#      \u2514\u2500\u2500 2\n\n# Search for an element\nif 4 in bst:\n    print(\"Found!\")\n\n# Traverse in different orders\nprint(list(bst.inorder()))    # [2, 3, 4, 5, 6, 7, 8]\nprint(list(bst.preorder()))   # [5, 3, 2, 4, 7, 6, 8]\nprint(list(bst.postorder()))  # [2, 4, 3, 6, 8, 7, 5]\nprint(list(bst.level_order()))  # [5, 3, 7, 2, 4, 6, 8]\n\n# Find min and max\nprint(bst.min())  # 2\nprint(bst.max())  # 8\n\n# Remove an element\nbst.remove(3)\n</code></pre>"},{"location":"getting-started/quickstart/#avl-tree","title":"AVL Tree","text":"<p>Self-balancing binary search tree:</p> <pre><code>from py_ds import AVLTree\n\n# Create an AVL tree (automatically balances)\navl = AVLTree([1, 2, 3, 4, 5, 6, 7])\n\n# Print the tree structure (visual representation)\nprint(avl)\n# Output:\n#      \u250c\u2500\u2500 7\n#  \u250c\u2500\u2500 6\n#  \u2502   \u2514\u2500\u2500 5\n#  4\n#  \u2502   \u250c\u2500\u2500 3\n#  \u2514\u2500\u2500 2\n#      \u2514\u2500\u2500 1\n\n# All BST operations work, with guaranteed O(log n) performance\navl.insert(8)\navl.remove(4)\n\n# Check if balanced\nprint(avl.height)  # Tree height is kept minimal\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#using-stacks-for-expression-evaluation","title":"Using Stacks for Expression Evaluation","text":"<pre><code>def evaluate_postfix(expression):\n    stack = Stack()\n    for token in expression.split():\n        if token.isdigit():\n            stack.push(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                stack.push(a + b)\n            elif token == '-':\n                stack.push(a - b)\n            elif token == '*':\n                stack.push(a * b)\n            elif token == '/':\n                stack.push(a // b)\n    return stack.pop()\n\nresult = evaluate_postfix(\"3 4 + 2 *\")  # (3+4)*2 = 14\n</code></pre>"},{"location":"getting-started/quickstart/#using-queues-for-bfs","title":"Using Queues for BFS","text":"<pre><code>def bfs_level_order(tree):\n    if not tree.root:\n        return []\n\n    queue = Queue([tree.root])\n    result = []\n\n    while not queue.is_empty():\n        node = queue.dequeue()\n        result.append(node.value)\n\n        if node.left:\n            queue.enqueue(node.left)\n        if node.right:\n            queue.enqueue(node.right)\n\n    return result\n</code></pre>"},{"location":"getting-started/quickstart/#using-heaps-for-top-k-elements","title":"Using Heaps for Top-K Elements","text":"<pre><code>def find_top_k(items, k):\n    min_heap = MinHeap()\n\n    for item in items:\n        if len(min_heap) &lt; k:\n            min_heap.push(item)\n        elif item &gt; min_heap.peek():\n            min_heap.pop()\n            min_heap.push(item)\n\n    return sorted(min_heap.to_list(), reverse=True)\n\ntop_3 = find_top_k([1, 5, 3, 9, 2, 7, 4, 8], 3)  # [9, 8, 7]\n</code></pre>"},{"location":"getting-started/quickstart/#type-hints","title":"Type Hints","text":"<p>All data structures support full type hints:</p> <pre><code>from typing import List\nfrom py_ds import Stack\n\ndef process_stack(items: List[int]) -&gt; Stack[int]:\n    stack = Stack(items)\n    return stack\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Data structures raise appropriate exceptions:</p> <pre><code>from py_ds import Stack, Queue\n\nstack = Stack()\ntry:\n    stack.pop()  # Raises IndexError\nexcept IndexError:\n    print(\"Stack is empty!\")\n\nqueue = Queue()\ntry:\n    queue.dequeue()  # Raises IndexError\nexcept IndexError:\n    print(\"Queue is empty!\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore detailed documentation for each Data Structure</li> <li>Check out the complete API Reference</li> <li>See Installation Guide for setup instructions</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Complete API documentation for all data structures in py-ds-academy.</p> <p>Browse individual data structure APIs using the navigation menu on the left, or see the overview below.</p>"},{"location":"reference/#linear-structures","title":"Linear Structures","text":"<ul> <li>Stack - Last-In-First-Out (LIFO) data structure</li> <li>Queue - First-In-First-Out (FIFO) data structure</li> <li>Singly Linked List - Linked list with forward links only</li> <li>Doubly Linked List - Linked list with forward and backward links</li> </ul>"},{"location":"reference/#trees","title":"Trees","text":"<ul> <li>Binary Tree - Tree where each node has at most two children</li> <li>Binary Search Tree - Ordered binary tree for efficient searching</li> <li>AVL Tree - Self-balancing binary search tree</li> </ul>"},{"location":"reference/#heaps","title":"Heaps","text":"<ul> <li>Min Heap - Complete binary tree with minimum at root</li> <li>Max Heap - Complete binary tree with maximum at root</li> </ul>"},{"location":"reference/avl-tree/","title":"AVL Tree","text":""},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree","title":"py_ds.datastructures.trees.avl.AVLTree","text":"<pre><code>AVLTree(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>BinarySearchTree[T]</code></p> <p>Initialize a binary tree.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to insert into the tree. If None, an empty tree is created.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None):\n    \"\"\"Initialize a binary tree.\n\n    Args:\n        items: Optional iterable of items to insert into the tree. If None,\n            an empty tree is created.\n    \"\"\"\n    self._root: _BinaryNode[T] | None = None\n    self.size: int = 0\n    items = items or []\n    for item in items:\n        self.insert(item)\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree-attributes","title":"Attributes","text":""},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre> <p>Check if the tree is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tree contains no elements, False otherwise.</p>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Get the height of the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The height of the tree. Returns -1 for an empty tree, 0 for a tree</p> <code>int</code> <p>with only a root node, and increases by 1 for each level below.</p>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree-functions","title":"Functions","text":""},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.remove","title":"remove","text":"<pre><code>remove(value: T) -&gt; None\n</code></pre> <p>Remove a value from the AVL tree.</p> <p>The tree is automatically rebalanced after removal to maintain the AVL property. If the value is not found, the tree remains unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to remove from the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/avl.py</code> <pre><code>def remove(self, value: T) -&gt; None:\n    \"\"\"Remove a value from the AVL tree.\n\n    The tree is automatically rebalanced after removal to maintain the AVL\n    property. If the value is not found, the tree remains unchanged.\n\n    Args:\n        value: The value to remove from the tree.\n    \"\"\"\n    self._root, removed = self._remove_recursive(self._root, value)\n    if removed:\n        self.size -= 1\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.insert","title":"insert","text":"<pre><code>insert(value: T) -&gt; None\n</code></pre> <p>Insert a value into the AVL tree.</p> <p>The tree is automatically rebalanced after insertion to maintain the AVL property, ensuring the tree remains balanced.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to insert into the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/avl.py</code> <pre><code>def insert(self, value: T) -&gt; None:\n    \"\"\"Insert a value into the AVL tree.\n\n    The tree is automatically rebalanced after insertion to maintain the AVL\n    property, ensuring the tree remains balanced.\n\n    Args:\n        value: The value to insert into the tree.\n    \"\"\"\n    self._root = self._insert_recursive(self._root, value)\n    self.size += 1\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all elements from the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all elements from the tree.\"\"\"\n    self._root = None\n    self.size = 0\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the tree.\n\n    Returns:\n        The number of elements in the tree.\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.inorder","title":"inorder","text":"<pre><code>inorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in inorder (left, root, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in inorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def inorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in inorder (left, root, right).\n\n    Yields:\n        Values from the tree in inorder traversal order.\n    \"\"\"\n\n    def _inorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _inorder(node.left)\n        yield node.value\n        yield from _inorder(node.right)\n\n    yield from _inorder(self._root)\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.preorder","title":"preorder","text":"<pre><code>preorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in preorder (root, left, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in preorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def preorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in preorder (root, left, right).\n\n    Yields:\n        Values from the tree in preorder traversal order.\n    \"\"\"\n\n    def _preorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield node.value\n        yield from _preorder(node.left)\n        yield from _preorder(node.right)\n\n    yield from _preorder(self._root)\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.postorder","title":"postorder","text":"<pre><code>postorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in postorder (left, right, root).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in postorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def postorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in postorder (left, right, root).\n\n    Yields:\n        Values from the tree in postorder traversal order.\n    \"\"\"\n\n    def _postorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _postorder(node.left)\n        yield from _postorder(node.right)\n        yield node.value\n\n    yield from _postorder(self._root)\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.level_order","title":"level_order","text":"<pre><code>level_order() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in level-order (breadth-first).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in level-order traversal, from top to bottom</p> <code>T</code> <p>and left to right at each level.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def level_order(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in level-order (breadth-first).\n\n    Yields:\n        Values from the tree in level-order traversal, from top to bottom\n        and left to right at each level.\n    \"\"\"\n    visited = [self._root] if self._root else []\n    while visited:\n        node = visited.pop(0)\n        yield node.value\n        if node.left:\n            visited.append(node.left)\n        if node.right:\n            visited.append(node.right)\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the tree.</p> <p>Returns:</p> Type Description <code>str</code> <p>A visual string representation of the tree structure. Returns 'EMPTY'</p> <code>str</code> <p>if the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the tree.\n\n    Returns:\n        A visual string representation of the tree structure. Returns 'EMPTY'\n        if the tree is empty.\n    \"\"\"\n    if self._root is None:\n        return 'EMPTY'\n\n    def build_tree_str(node: _BinaryNode[T], prefix: str, is_left: bool) -&gt; str:\n        tree = ''\n\n        if node.right:\n            tree += build_tree_str(node.right, prefix + ('\u2502   ' if is_left else '    '), False)\n\n        tree += prefix + ('\u2514\u2500\u2500 ' if is_left else '\u250c\u2500\u2500 ') + str(node.value) + '\\n'\n\n        if node.left:\n            tree += build_tree_str(node.left, prefix + ('    ' if is_left else '\u2502   '), True)\n        return tree\n\n    result = ''\n    if self._root.right:\n        right_result = build_tree_str(self._root.right, '', False)\n        result += right_result\n\n    result += f'{self._root.value}\\n'\n\n    if self._root.left:\n        left_result = build_tree_str(self._root.left, '', True)\n        result += left_result\n\n    return result\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.min","title":"min","text":"<pre><code>min() -&gt; T\n</code></pre> <p>Get the minimum value in the tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>The minimum value in the tree.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def min(self) -&gt; T:\n    \"\"\"Get the minimum value in the tree.\n\n    Returns:\n        The minimum value in the tree.\n\n    Raises:\n        ValueError: If the tree is empty.\n    \"\"\"\n    if self.is_empty:\n        raise ValueError('Empty tree')\n    return self._get_min_node(self._root).value\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.max","title":"max","text":"<pre><code>max() -&gt; T\n</code></pre> <p>Get the maximum value in the tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>The maximum value in the tree.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def max(self) -&gt; T:\n    \"\"\"Get the maximum value in the tree.\n\n    Returns:\n        The maximum value in the tree.\n\n    Raises:\n        ValueError: If the tree is empty.\n    \"\"\"\n    if self.is_empty:\n        raise ValueError('Empty tree')\n    return self._get_max_node(self._root).value\n</code></pre>"},{"location":"reference/avl-tree/#py_ds.datastructures.trees.avl.AVLTree.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: T) -&gt; bool\n</code></pre> <p>Check if a value is in the tree.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is found in the tree, False otherwise.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if a value is in the tree.\n\n    Args:\n        item: The value to search for.\n\n    Returns:\n        True if the value is found in the tree, False otherwise.\n    \"\"\"\n    if self.is_empty:\n        return False\n    curr = self._root\n    while curr is not None:\n        if item == curr.value:\n            return True\n        curr = curr.left if item &lt; curr.value else curr.right\n    return False\n</code></pre>"},{"location":"reference/binary-search-tree/","title":"Binary Search Tree","text":""},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree","title":"py_ds.datastructures.trees.binary_search_tree.BinarySearchTree","text":"<pre><code>BinarySearchTree(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>BinaryTree[T]</code></p> <p>Initialize a binary tree.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to insert into the tree. If None, an empty tree is created.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None):\n    \"\"\"Initialize a binary tree.\n\n    Args:\n        items: Optional iterable of items to insert into the tree. If None,\n            an empty tree is created.\n    \"\"\"\n    self._root: _BinaryNode[T] | None = None\n    self.size: int = 0\n    items = items or []\n    for item in items:\n        self.insert(item)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree-attributes","title":"Attributes","text":""},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre> <p>Check if the tree is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tree contains no elements, False otherwise.</p>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Get the height of the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The height of the tree. Returns -1 for an empty tree, 0 for a tree</p> <code>int</code> <p>with only a root node, and increases by 1 for each level below.</p>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree-functions","title":"Functions","text":""},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.insert","title":"insert","text":"<pre><code>insert(value: T) -&gt; None\n</code></pre> <p>Insert a value into the binary search tree.</p> <p>The value is inserted according to the binary search tree property: values less than or equal to a node go to the left, values greater than a node go to the right.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to insert into the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def insert(self, value: T) -&gt; None:\n    \"\"\"Insert a value into the binary search tree.\n\n    The value is inserted according to the binary search tree property:\n    values less than or equal to a node go to the left, values greater\n    than a node go to the right.\n\n    Args:\n        value: The value to insert into the tree.\n    \"\"\"\n    insert_node = _BinaryNode(value=value)\n    self.size += 1\n    if self._root is None:\n        self._root = insert_node\n        return\n    curr = self._root\n    while True:\n        if value &lt;= curr.value:\n            if curr.left is None:\n                curr.left = insert_node\n                break\n            curr = curr.left\n        else:\n            if curr.right is None:\n                curr.right = insert_node\n                break\n            curr = curr.right\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.remove","title":"remove","text":"<pre><code>remove(value: T) -&gt; None\n</code></pre> <p>Remove a value from the binary search tree.</p> <p>If the value is not found, the tree remains unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to remove from the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def remove(self, value: T) -&gt; None:\n    \"\"\"Remove a value from the binary search tree.\n\n    If the value is not found, the tree remains unchanged.\n\n    Args:\n        value: The value to remove from the tree.\n    \"\"\"\n    if self.is_empty:\n        return\n    current = self._root\n    parent: _BinaryNode[T] = None\n    while current and current.value != value:\n        parent, current = current, (current.left if value &lt;= current.value else current.right)\n\n    if current is None:\n        return\n\n    self.size -= 1\n\n    if current.left is None or current.right is None:\n        child = current.left if current.left is not None else current.right\n        self._replace_child(parent, current, child)\n        return\n\n    succ_parent, succ = current, current.right\n    while succ.left is not None:\n        succ_parent, succ = succ, succ.left\n\n    current.value = succ.value\n    self._replace_child(succ_parent, succ, succ.right)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.min","title":"min","text":"<pre><code>min() -&gt; T\n</code></pre> <p>Get the minimum value in the tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>The minimum value in the tree.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def min(self) -&gt; T:\n    \"\"\"Get the minimum value in the tree.\n\n    Returns:\n        The minimum value in the tree.\n\n    Raises:\n        ValueError: If the tree is empty.\n    \"\"\"\n    if self.is_empty:\n        raise ValueError('Empty tree')\n    return self._get_min_node(self._root).value\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.max","title":"max","text":"<pre><code>max() -&gt; T\n</code></pre> <p>Get the maximum value in the tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>The maximum value in the tree.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def max(self) -&gt; T:\n    \"\"\"Get the maximum value in the tree.\n\n    Returns:\n        The maximum value in the tree.\n\n    Raises:\n        ValueError: If the tree is empty.\n    \"\"\"\n    if self.is_empty:\n        raise ValueError('Empty tree')\n    return self._get_max_node(self._root).value\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: T) -&gt; bool\n</code></pre> <p>Check if a value is in the tree.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is found in the tree, False otherwise.</p> Source code in <code>src/py_ds/datastructures/trees/binary_search_tree.py</code> <pre><code>def __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if a value is in the tree.\n\n    Args:\n        item: The value to search for.\n\n    Returns:\n        True if the value is found in the tree, False otherwise.\n    \"\"\"\n    if self.is_empty:\n        return False\n    curr = self._root\n    while curr is not None:\n        if item == curr.value:\n            return True\n        curr = curr.left if item &lt; curr.value else curr.right\n    return False\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all elements from the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all elements from the tree.\"\"\"\n    self._root = None\n    self.size = 0\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the tree.\n\n    Returns:\n        The number of elements in the tree.\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.inorder","title":"inorder","text":"<pre><code>inorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in inorder (left, root, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in inorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def inorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in inorder (left, root, right).\n\n    Yields:\n        Values from the tree in inorder traversal order.\n    \"\"\"\n\n    def _inorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _inorder(node.left)\n        yield node.value\n        yield from _inorder(node.right)\n\n    yield from _inorder(self._root)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.preorder","title":"preorder","text":"<pre><code>preorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in preorder (root, left, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in preorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def preorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in preorder (root, left, right).\n\n    Yields:\n        Values from the tree in preorder traversal order.\n    \"\"\"\n\n    def _preorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield node.value\n        yield from _preorder(node.left)\n        yield from _preorder(node.right)\n\n    yield from _preorder(self._root)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.postorder","title":"postorder","text":"<pre><code>postorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in postorder (left, right, root).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in postorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def postorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in postorder (left, right, root).\n\n    Yields:\n        Values from the tree in postorder traversal order.\n    \"\"\"\n\n    def _postorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _postorder(node.left)\n        yield from _postorder(node.right)\n        yield node.value\n\n    yield from _postorder(self._root)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.level_order","title":"level_order","text":"<pre><code>level_order() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in level-order (breadth-first).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in level-order traversal, from top to bottom</p> <code>T</code> <p>and left to right at each level.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def level_order(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in level-order (breadth-first).\n\n    Yields:\n        Values from the tree in level-order traversal, from top to bottom\n        and left to right at each level.\n    \"\"\"\n    visited = [self._root] if self._root else []\n    while visited:\n        node = visited.pop(0)\n        yield node.value\n        if node.left:\n            visited.append(node.left)\n        if node.right:\n            visited.append(node.right)\n</code></pre>"},{"location":"reference/binary-search-tree/#py_ds.datastructures.trees.binary_search_tree.BinarySearchTree.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the tree.</p> <p>Returns:</p> Type Description <code>str</code> <p>A visual string representation of the tree structure. Returns 'EMPTY'</p> <code>str</code> <p>if the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the tree.\n\n    Returns:\n        A visual string representation of the tree structure. Returns 'EMPTY'\n        if the tree is empty.\n    \"\"\"\n    if self._root is None:\n        return 'EMPTY'\n\n    def build_tree_str(node: _BinaryNode[T], prefix: str, is_left: bool) -&gt; str:\n        tree = ''\n\n        if node.right:\n            tree += build_tree_str(node.right, prefix + ('\u2502   ' if is_left else '    '), False)\n\n        tree += prefix + ('\u2514\u2500\u2500 ' if is_left else '\u250c\u2500\u2500 ') + str(node.value) + '\\n'\n\n        if node.left:\n            tree += build_tree_str(node.left, prefix + ('    ' if is_left else '\u2502   '), True)\n        return tree\n\n    result = ''\n    if self._root.right:\n        right_result = build_tree_str(self._root.right, '', False)\n        result += right_result\n\n    result += f'{self._root.value}\\n'\n\n    if self._root.left:\n        left_result = build_tree_str(self._root.left, '', True)\n        result += left_result\n\n    return result\n</code></pre>"},{"location":"reference/binary-tree/","title":"Binary Tree","text":""},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree","title":"py_ds.datastructures.trees.base.BinaryTree","text":"<pre><code>BinaryTree(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Initialize a binary tree.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to insert into the tree. If None, an empty tree is created.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None):\n    \"\"\"Initialize a binary tree.\n\n    Args:\n        items: Optional iterable of items to insert into the tree. If None,\n            an empty tree is created.\n    \"\"\"\n    self._root: _BinaryNode[T] | None = None\n    self.size: int = 0\n    items = items or []\n    for item in items:\n        self.insert(item)\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree-attributes","title":"Attributes","text":""},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre> <p>Check if the tree is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tree contains no elements, False otherwise.</p>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Get the height of the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The height of the tree. Returns -1 for an empty tree, 0 for a tree</p> <code>int</code> <p>with only a root node, and increases by 1 for each level below.</p>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree-functions","title":"Functions","text":""},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.insert","title":"insert  <code>abstractmethod</code>","text":"<pre><code>insert(value: T) -&gt; None\n</code></pre> <p>Add a value to the tree.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to insert into the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>@abstractmethod\ndef insert(self, value: T) -&gt; None:\n    \"\"\"Add a value to the tree.\n\n    Args:\n        value: The value to insert into the tree.\n    \"\"\"\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.remove","title":"remove  <code>abstractmethod</code>","text":"<pre><code>remove(value: T) -&gt; None\n</code></pre> <p>Remove a value from the tree.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to remove from the tree.</p> required Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>@abstractmethod\ndef remove(self, value: T) -&gt; None:\n    \"\"\"Remove a value from the tree.\n\n    Args:\n        value: The value to remove from the tree.\n    \"\"\"\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all elements from the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all elements from the tree.\"\"\"\n    self._root = None\n    self.size = 0\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the tree.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the tree.\n\n    Returns:\n        The number of elements in the tree.\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.inorder","title":"inorder","text":"<pre><code>inorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in inorder (left, root, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in inorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def inorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in inorder (left, root, right).\n\n    Yields:\n        Values from the tree in inorder traversal order.\n    \"\"\"\n\n    def _inorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _inorder(node.left)\n        yield node.value\n        yield from _inorder(node.right)\n\n    yield from _inorder(self._root)\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.preorder","title":"preorder","text":"<pre><code>preorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in preorder (root, left, right).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in preorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def preorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in preorder (root, left, right).\n\n    Yields:\n        Values from the tree in preorder traversal order.\n    \"\"\"\n\n    def _preorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield node.value\n        yield from _preorder(node.left)\n        yield from _preorder(node.right)\n\n    yield from _preorder(self._root)\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.postorder","title":"postorder","text":"<pre><code>postorder() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in postorder (left, right, root).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in postorder traversal order.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def postorder(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in postorder (left, right, root).\n\n    Yields:\n        Values from the tree in postorder traversal order.\n    \"\"\"\n\n    def _postorder(node: _BinaryNode[T] | None):\n        if node is None:\n            return\n        yield from _postorder(node.left)\n        yield from _postorder(node.right)\n        yield node.value\n\n    yield from _postorder(self._root)\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.level_order","title":"level_order","text":"<pre><code>level_order() -&gt; Iterator[T]\n</code></pre> <p>Traverse the tree in level-order (breadth-first).</p> <p>Yields:</p> Type Description <code>T</code> <p>Values from the tree in level-order traversal, from top to bottom</p> <code>T</code> <p>and left to right at each level.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def level_order(self) -&gt; Iterator[T]:\n    \"\"\"Traverse the tree in level-order (breadth-first).\n\n    Yields:\n        Values from the tree in level-order traversal, from top to bottom\n        and left to right at each level.\n    \"\"\"\n    visited = [self._root] if self._root else []\n    while visited:\n        node = visited.pop(0)\n        yield node.value\n        if node.left:\n            visited.append(node.left)\n        if node.right:\n            visited.append(node.right)\n</code></pre>"},{"location":"reference/binary-tree/#py_ds.datastructures.trees.base.BinaryTree.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the tree.</p> <p>Returns:</p> Type Description <code>str</code> <p>A visual string representation of the tree structure. Returns 'EMPTY'</p> <code>str</code> <p>if the tree is empty.</p> Source code in <code>src/py_ds/datastructures/trees/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the tree.\n\n    Returns:\n        A visual string representation of the tree structure. Returns 'EMPTY'\n        if the tree is empty.\n    \"\"\"\n    if self._root is None:\n        return 'EMPTY'\n\n    def build_tree_str(node: _BinaryNode[T], prefix: str, is_left: bool) -&gt; str:\n        tree = ''\n\n        if node.right:\n            tree += build_tree_str(node.right, prefix + ('\u2502   ' if is_left else '    '), False)\n\n        tree += prefix + ('\u2514\u2500\u2500 ' if is_left else '\u250c\u2500\u2500 ') + str(node.value) + '\\n'\n\n        if node.left:\n            tree += build_tree_str(node.left, prefix + ('    ' if is_left else '\u2502   '), True)\n        return tree\n\n    result = ''\n    if self._root.right:\n        right_result = build_tree_str(self._root.right, '', False)\n        result += right_result\n\n    result += f'{self._root.value}\\n'\n\n    if self._root.left:\n        left_result = build_tree_str(self._root.left, '', True)\n        result += left_result\n\n    return result\n</code></pre>"},{"location":"reference/doubly-linked-list/","title":"Doubly Linked List","text":""},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList","title":"py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList","text":"<pre><code>DoublyLinkedList(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>LinkedList[T]</code></p> <p>A doubly linked list with forward and backward links.</p> <p>Advantages over singly linked list include O(1) append (with tail pointer), O(1) tail access, bidirectional traversal, and more efficient deletion when node reference is known.</p> <p>Initialize the doubly linked list with optional items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to initialize the list with.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None) -&gt; None:\n    \"\"\"Initialize the doubly linked list with optional items.\n\n    Args:\n        items: Optional iterable of items to initialize the list with.\n    \"\"\"\n    self._head: _DoublyNode[T] | None = None\n    self._tail: _DoublyNode[T] | None = None\n    super().__init__(items)\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList-functions","title":"Functions","text":""},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.append","title":"append","text":"<pre><code>append(value: T) -&gt; None\n</code></pre> <p>Add a value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to append to the list.</p> required <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def append(self, value: T) -&gt; None:\n    \"\"\"Add a value to the end of the list.\n\n    Args:\n        value: The value to append to the list.\n\n    Time complexity: O(1).\n    \"\"\"\n    node = _DoublyNode(value)\n    if self._head is None:\n        self._head = self._tail = node\n    else:\n        self._tail.next = node\n        node.prev = self._tail\n        self._tail = node\n    self._length += 1\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.prepend","title":"prepend","text":"<pre><code>prepend(value: T) -&gt; None\n</code></pre> <p>Add a value to the beginning of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to prepend to the list.</p> required <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def prepend(self, value: T) -&gt; None:\n    \"\"\"Add a value to the beginning of the list.\n\n    Args:\n        value: The value to prepend to the list.\n\n    Time complexity: O(1).\n    \"\"\"\n    node = _DoublyNode(value)\n    if self._head is None:\n        self._head = self._tail = node\n    else:\n        node.next = self._head\n        self._head.prev = node\n        self._head = node\n    self._length += 1\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.insert","title":"insert","text":"<pre><code>insert(index: int, value: T) -&gt; None\n</code></pre> <p>Insert a value at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position at which to insert the value.</p> required <code>value</code> <code>T</code> <p>The value to insert.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def insert(self, index: int, value: T) -&gt; None:\n    \"\"\"Insert a value at a specific index.\n\n    Args:\n        index: The position at which to insert the value.\n        value: The value to insert.\n\n    Raises:\n        IndexError: If index is out of bounds.\n\n    Time complexity: O(n).\n    \"\"\"\n    if index == self._length:\n        self.append(value)\n        return\n\n    new_node = _DoublyNode(value)\n    index_node = self._get_node_at(index)\n    prev = index_node.prev\n\n    new_node.next = index_node\n    index_node.prev = new_node\n\n    if prev:\n        prev.next = new_node\n        new_node.prev = prev\n    else:\n        self._head = new_node\n    self._length += 1\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.remove","title":"remove","text":"<pre><code>remove(value: T) -&gt; None\n</code></pre> <p>Remove the first occurrence of <code>value</code> from the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to remove from the list.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not found.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def remove(self, value: T) -&gt; None:\n    \"\"\"Remove the first occurrence of `value` from the list.\n\n    Args:\n        value: The value to remove from the list.\n\n    Raises:\n        ValueError: If the value is not found.\n\n    Time complexity: O(n).\n    \"\"\"\n    curr = self._head\n    while curr and curr.value != value:\n        curr = curr.next\n    if curr is None or curr.value != value:\n        raise ValueError('value not found')\n\n    prev = curr.prev\n    next_ = curr.next\n\n    if prev:\n        prev.next = next_\n    else:\n        self._head = next_\n        if self._head:\n            self._head.prev = None\n\n    if next_:\n        next_.prev = prev\n    else:\n        self._tail = prev\n        if self._tail:\n            self._tail.next = None\n    self._length -= 1\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.pop","title":"pop","text":"<pre><code>pop(index: int = -1) -&gt; T\n</code></pre> <p>Remove and return the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>0-based index, negative indexes supported (Python style). Defaults to -1 (last element).</p> <code>-1</code> <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the list is empty or index is invalid.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def pop(self, index: int = -1) -&gt; T:\n    \"\"\"Remove and return the item at the given index.\n\n    Args:\n        index: 0-based index, negative indexes supported (Python style).\n            Defaults to -1 (last element).\n\n    Returns:\n        The value at the specified index.\n\n    Raises:\n        IndexError: If the list is empty or index is invalid.\n\n    Time complexity: O(n).\n    \"\"\"\n    curr = self._get_node_at(index)\n    value = curr.value\n    prev, next_ = curr.prev, curr.next\n\n    if prev:\n        prev.next = next_\n    else:\n        self._head = next_\n\n    if next_:\n        next_.prev = prev\n    else:\n        self._tail = prev\n    self._length -= 1\n    return value\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all elements from the list.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all elements from the list.\n\n    Time complexity: O(n).\n    \"\"\"\n    self._head = self._tail = None\n    self._length = 0\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.head","title":"head","text":"<pre><code>head() -&gt; T | None\n</code></pre> <p>Return the first value in the list.</p> <p>Returns:</p> Type Description <code>T | None</code> <p>The first value in the list, or None if the list is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def head(self) -&gt; T | None:\n    \"\"\"Return the first value in the list.\n\n    Returns:\n        The first value in the list, or None if the list is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    return self._head.value if self._head else None\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.tail","title":"tail","text":"<pre><code>tail() -&gt; T | None\n</code></pre> <p>Return the last value in the list.</p> <p>Returns:</p> Type Description <code>T | None</code> <p>The last value in the list, or None if the list is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def tail(self) -&gt; T | None:\n    \"\"\"Return the last value in the list.\n\n    Returns:\n        The last value in the list, or None if the list is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    return self._tail.value if self._tail else None\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.reverse_iter","title":"reverse_iter","text":"<pre><code>reverse_iter() -&gt; Iterator[T]\n</code></pre> <p>Iterate through values from tail to head.</p> <p>This is a doubly linked list advantage, allowing efficient reverse traversal.</p> <p>Yields:</p> Type Description <code>T</code> <p>The values in the list from tail to head.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def reverse_iter(self) -&gt; Iterator[T]:\n    \"\"\"Iterate through values from tail to head.\n\n    This is a doubly linked list advantage, allowing efficient reverse\n    traversal.\n\n    Yields:\n        The values in the list from tail to head.\n\n    Time complexity: O(n).\n    \"\"\"\n    curr = self._tail\n    while curr:\n        yield curr.value\n        curr = curr.prev\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the linked list.</p> <p>Returns:</p> Type Description <code>str</code> <p>A visual representation of the linked list.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/doubly_linked.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the linked list.\n\n    Returns:\n        A visual representation of the linked list.\n\n    Time complexity: O(n).\n    \"\"\"\n    if not self:\n        return 'HEAD \u21c6 TAIL'\n    return 'HEAD \u21c6 ' + ' \u21c6 '.join(str(item) for item in self) + ' \u21c6 TAIL'\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.find","title":"find","text":"<pre><code>find(value: T) -&gt; int\n</code></pre> <p>Return the index of the first occurrence of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the first occurrence of the value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not found in the list.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def find(self, value: T) -&gt; int:\n    \"\"\"Return the index of the first occurrence of a value.\n\n    Args:\n        value: The value to search for.\n\n    Returns:\n        The index of the first occurrence of the value.\n\n    Raises:\n        ValueError: If the value is not found in the list.\n    \"\"\"\n    for i, node_value in enumerate(self):\n        if value == node_value:\n            return i\n    raise ValueError('value not found')\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the list.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the linked list.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the list.\n\n    Returns:\n        The number of elements in the linked list.\n    \"\"\"\n    return self._length\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the list.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the list is empty, True otherwise.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the list.\n\n    Returns:\n        False if the list is empty, True otherwise.\n    \"\"\"\n    return self._length &gt; 0\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre> <p>Get the value at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>0-based index, negative indexes supported (Python style).</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __getitem__(self, index: int) -&gt; T:\n    \"\"\"Get the value at the given index.\n\n    Args:\n        index: 0-based index, negative indexes supported (Python style).\n\n    Returns:\n        The value at the specified index.\n\n    Raises:\n        IndexError: If the index is out of range.\n    \"\"\"\n    return self._get_node_at(index).value\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index: int, value: T) -&gt; None\n</code></pre> <p>Set item at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position at which to set the value. 0-based index, negative indexes supported (Python style).</p> required <code>value</code> <code>T</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __setitem__(self, index: int, value: T) -&gt; None:\n    \"\"\"Set item at the specified index.\n\n    Args:\n        index: The position at which to set the value.\n            0-based index, negative indexes supported (Python style).\n        value: The value to set.\n\n    Raises:\n        IndexError: If index is out of bounds.\n\n    Time complexity: O(n).\n    \"\"\"\n    self._get_node_at(index).value = value\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[T]\n</code></pre> <p>Iterate through values in the list.</p> <p>Yields:</p> Type Description <code>T</code> <p>The values in the list from head to tail.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Iterate through values in the list.\n\n    Yields:\n        The values in the list from head to tail.\n    \"\"\"\n    curr = self._head\n    while curr:\n        yield curr.value\n        curr = curr.next\n</code></pre>"},{"location":"reference/doubly-linked-list/#py_ds.datastructures.linked_lists.doubly_linked.DoublyLinkedList.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the linked list.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation showing the class name and list contents.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the linked list.\n\n    Returns:\n        A string representation showing the class name and list contents.\n    \"\"\"\n    return f'{self.__class__.__name__}({list(self)})'\n</code></pre>"},{"location":"reference/max-heap/","title":"Max Heap","text":""},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap","title":"py_ds.datastructures.heaps.MaxHeap","text":"<pre><code>MaxHeap(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>Heap</code></p> <p>A max-heap implementation.</p> <p>In a max-heap, the parent node is always greater than or equal to its children. The root element is the maximum value in the heap.</p> <p>Initialize the heap with optional items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to initialize the heap with. If None, creates an empty heap.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None):\n    \"\"\"Initialize the heap with optional items.\n\n    Args:\n        items: Optional iterable of items to initialize the heap with.\n            If None, creates an empty heap.\n    \"\"\"\n    items = items or []\n    self._items: list[T] = []\n    self._size: int = 0\n    for item in items:\n        self.push(item)\n</code></pre>"},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap-functions","title":"Functions","text":""},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap.push","title":"push","text":"<pre><code>push(item: T) -&gt; None\n</code></pre> <p>Add an item to the heap.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add to the heap.</p> required <p>Time complexity: O(log n) where n is the number of elements.</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def push(self, item: T) -&gt; None:\n    \"\"\"Add an item to the heap.\n\n    Args:\n        item: The item to add to the heap.\n\n    Time complexity: O(log n) where n is the number of elements.\n    \"\"\"\n    index = self._size\n    if index &gt;= len(self._items):\n        self._items.append(item)\n    else:\n        self._items[index] = item\n    self._size += 1\n    self._heapify_up()\n</code></pre>"},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap.pop","title":"pop","text":"<pre><code>pop() -&gt; T\n</code></pre> <p>Remove and return the root element of the heap.</p> <p>Returns:</p> Type Description <code>T</code> <p>The root element of the heap (minimum for MinHeap, maximum for MaxHeap).</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the heap is empty.</p> <p>Time complexity: O(log n) where n is the number of elements.</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def pop(self) -&gt; T:\n    \"\"\"Remove and return the root element of the heap.\n\n    Returns:\n        The root element of the heap (minimum for MinHeap, maximum for MaxHeap).\n\n    Raises:\n        IndexError: If the heap is empty.\n\n    Time complexity: O(log n) where n is the number of elements.\n    \"\"\"\n    if not self:\n        raise IndexError('pop from an empty heap')\n    item = self._items[0]\n    self._items[0] = self._items[self._size - 1]\n    self._size -= 1\n    self._heapify_down()\n    return item\n</code></pre>"},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap.peek","title":"peek","text":"<pre><code>peek() -&gt; T\n</code></pre> <p>Return the root element without removing it.</p> <p>Returns:</p> Type Description <code>T</code> <p>The root element of the heap (minimum for MinHeap, maximum for MaxHeap).</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the heap is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def peek(self) -&gt; T:\n    \"\"\"Return the root element without removing it.\n\n    Returns:\n        The root element of the heap (minimum for MinHeap, maximum for MaxHeap).\n\n    Raises:\n        IndexError: If the heap is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if not self:\n        raise IndexError('peek from an empty heap')\n    return self._items[0]\n</code></pre>"},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the heap.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the heap.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the heap.\n\n    Returns:\n        The number of elements in the heap.\n\n    Time complexity: O(1).\n    \"\"\"\n    return self._size\n</code></pre>"},{"location":"reference/max-heap/#py_ds.datastructures.heaps.MaxHeap.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the heap.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the heap is empty, True otherwise.</p> <p>Enables: <code>if heap: ...</code></p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the heap.\n\n    Returns:\n        False if the heap is empty, True otherwise.\n\n    Enables: `if heap: ...`\n    \"\"\"\n    return self._size &gt; 0\n</code></pre>"},{"location":"reference/min-heap/","title":"Min Heap","text":""},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap","title":"py_ds.datastructures.heaps.MinHeap","text":"<pre><code>MinHeap(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>Heap</code></p> <p>A min-heap implementation.</p> <p>In a min-heap, the parent node is always less than or equal to its children. The root element is the minimum value in the heap.</p> <p>Initialize the heap with optional items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to initialize the heap with. If None, creates an empty heap.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None):\n    \"\"\"Initialize the heap with optional items.\n\n    Args:\n        items: Optional iterable of items to initialize the heap with.\n            If None, creates an empty heap.\n    \"\"\"\n    items = items or []\n    self._items: list[T] = []\n    self._size: int = 0\n    for item in items:\n        self.push(item)\n</code></pre>"},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap-functions","title":"Functions","text":""},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap.push","title":"push","text":"<pre><code>push(item: T) -&gt; None\n</code></pre> <p>Add an item to the heap.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add to the heap.</p> required <p>Time complexity: O(log n) where n is the number of elements.</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def push(self, item: T) -&gt; None:\n    \"\"\"Add an item to the heap.\n\n    Args:\n        item: The item to add to the heap.\n\n    Time complexity: O(log n) where n is the number of elements.\n    \"\"\"\n    index = self._size\n    if index &gt;= len(self._items):\n        self._items.append(item)\n    else:\n        self._items[index] = item\n    self._size += 1\n    self._heapify_up()\n</code></pre>"},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap.pop","title":"pop","text":"<pre><code>pop() -&gt; T\n</code></pre> <p>Remove and return the root element of the heap.</p> <p>Returns:</p> Type Description <code>T</code> <p>The root element of the heap (minimum for MinHeap, maximum for MaxHeap).</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the heap is empty.</p> <p>Time complexity: O(log n) where n is the number of elements.</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def pop(self) -&gt; T:\n    \"\"\"Remove and return the root element of the heap.\n\n    Returns:\n        The root element of the heap (minimum for MinHeap, maximum for MaxHeap).\n\n    Raises:\n        IndexError: If the heap is empty.\n\n    Time complexity: O(log n) where n is the number of elements.\n    \"\"\"\n    if not self:\n        raise IndexError('pop from an empty heap')\n    item = self._items[0]\n    self._items[0] = self._items[self._size - 1]\n    self._size -= 1\n    self._heapify_down()\n    return item\n</code></pre>"},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap.peek","title":"peek","text":"<pre><code>peek() -&gt; T\n</code></pre> <p>Return the root element without removing it.</p> <p>Returns:</p> Type Description <code>T</code> <p>The root element of the heap (minimum for MinHeap, maximum for MaxHeap).</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the heap is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def peek(self) -&gt; T:\n    \"\"\"Return the root element without removing it.\n\n    Returns:\n        The root element of the heap (minimum for MinHeap, maximum for MaxHeap).\n\n    Raises:\n        IndexError: If the heap is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if not self:\n        raise IndexError('peek from an empty heap')\n    return self._items[0]\n</code></pre>"},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the heap.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the heap.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the heap.\n\n    Returns:\n        The number of elements in the heap.\n\n    Time complexity: O(1).\n    \"\"\"\n    return self._size\n</code></pre>"},{"location":"reference/min-heap/#py_ds.datastructures.heaps.MinHeap.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the heap.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the heap is empty, True otherwise.</p> <p>Enables: <code>if heap: ...</code></p> Source code in <code>src/py_ds/datastructures/heaps.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the heap.\n\n    Returns:\n        False if the heap is empty, True otherwise.\n\n    Enables: `if heap: ...`\n    \"\"\"\n    return self._size &gt; 0\n</code></pre>"},{"location":"reference/queue/","title":"Queue","text":""},{"location":"reference/queue/#py_ds.datastructures.queue.Queue","title":"py_ds.datastructures.queue.Queue","text":"<pre><code>Queue(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A simple FIFO (first-in, first-out) queue.</p> <p>Backed by a Python list, providing O(1) enqueue and O(1) dequeue operations.</p> <p>Initialize the queue.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of initial items.    The first item of the iterable becomes the front of the queue.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None) -&gt; None:\n    \"\"\"Initialize the queue.\n\n    Args:\n        items: Optional iterable of initial items.\n               The first item of the iterable becomes the front of the queue.\n    \"\"\"\n    self._items = list(items) if items else []\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue-functions","title":"Functions","text":""},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.enqueue","title":"enqueue","text":"<pre><code>enqueue(item: T) -&gt; None\n</code></pre> <p>Add an item to the back of the queue.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add to the queue.</p> required <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def enqueue(self, item: T) -&gt; None:\n    \"\"\"Add an item to the back of the queue.\n\n    Args:\n        item: The item to add to the queue.\n\n    Time complexity: O(1).\n    \"\"\"\n    self._items.append(item)\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.dequeue","title":"dequeue","text":"<pre><code>dequeue() -&gt; T\n</code></pre> <p>Remove and return the front item of the queue.</p> <p>Returns:</p> Type Description <code>T</code> <p>The item that was at the front of the queue.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the queue is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def dequeue(self) -&gt; T:\n    \"\"\"Remove and return the front item of the queue.\n\n    Returns:\n        The item that was at the front of the queue.\n\n    Raises:\n        IndexError: If the queue is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if self.is_empty():\n        raise IndexError('dequeue from empty queue')\n    return self._items.pop(0)\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.peek","title":"peek","text":"<pre><code>peek() -&gt; T\n</code></pre> <p>Return the front item without removing it.</p> <p>Returns:</p> Type Description <code>T</code> <p>The item at the front of the queue.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the queue is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def peek(self) -&gt; T:\n    \"\"\"Return the front item without removing it.\n\n    Returns:\n        The item at the front of the queue.\n\n    Raises:\n        IndexError: If the queue is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if self.is_empty():\n        raise IndexError('peek from empty queue')\n    return self._items[0]\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the queue is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the queue contains no items, False otherwise.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the queue is empty.\n\n    Returns:\n        True if the queue contains no items, False otherwise.\n\n    Time complexity: O(1).\n    \"\"\"\n    return len(self._items) == 0\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.extend","title":"extend","text":"<pre><code>extend(items: Iterable[T]) -&gt; None\n</code></pre> <p>Enqueue multiple items in the order provided.</p> <p>The first item of the iterable becomes the next after the current back.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T]</code> <p>An iterable of items to enqueue.</p> required <p>Time complexity: O(k), where k is the number of items.</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def extend(self, items: Iterable[T]) -&gt; None:\n    \"\"\"Enqueue multiple items in the order provided.\n\n    The first item of the iterable becomes the next after the current back.\n\n    Args:\n        items: An iterable of items to enqueue.\n\n    Time complexity: O(k), where k is the number of items.\n    \"\"\"\n    for item in items:\n        self.enqueue(item)\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all items from the queue.</p> <p>After this call, is_empty() returns True and len(queue) == 0.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items from the queue.\n\n    After this call, is_empty() returns True and len(queue) == 0.\n\n    Time complexity: O(1).\n    \"\"\"\n    self._items = []\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[T]\n</code></pre> <p>Convert the queue to a Python list.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A shallow copy of the queue contents as a list, ordered from</p> <code>list[T]</code> <p>front to back.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def to_list(self) -&gt; list[T]:\n    \"\"\"Convert the queue to a Python list.\n\n    Returns:\n        A shallow copy of the queue contents as a list, ordered from\n        front to back.\n\n    Time complexity: O(n).\n    \"\"\"\n    return self._items[::]\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of items in the queue.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items in the queue.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the queue.\n\n    Returns:\n        The number of items in the queue.\n\n    Time complexity: O(1).\n    \"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the queue.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the queue is empty, True otherwise.</p> <p>Enables: <code>if queue: ...</code></p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the queue.\n\n    Returns:\n        False if the queue is empty, True otherwise.\n\n    Enables: `if queue: ...`\n    \"\"\"\n    return len(self._items) &gt; 0\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[T]\n</code></pre> <p>Iterate over the items in the queue from front to back.</p> <p>Yields:</p> Type Description <code>T</code> <p>Each item in the queue, starting from the front.</p> Example <p>q = Queue([1, 2, 3]) list(q)  # [1, 2, 3]  (front to back)</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Iterate over the items in the queue from front to back.\n\n    Yields:\n        Each item in the queue, starting from the front.\n\n    Example:\n        q = Queue([1, 2, 3])\n        list(q)  # [1, 2, 3]  (front to back)\n    \"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"reference/queue/#py_ds.datastructures.queue.Queue.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the queue.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation showing the class name and queue contents.</p> Example <p>Queue([1, 2, 3])</p> Source code in <code>src/py_ds/datastructures/queue.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the queue.\n\n    Returns:\n        A string representation showing the class name and queue contents.\n\n    Example:\n        Queue([1, 2, 3])\n    \"\"\"\n    return f'Queue({self._items})'\n</code></pre>"},{"location":"reference/singly-linked-list/","title":"Linked List","text":""},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList","title":"py_ds.datastructures.linked_lists.singly_linked.LinkedList","text":"<pre><code>LinkedList(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A singly linked list supporting typical operations.</p> <p>Supports append/prepend, insert at index, remove by value, iteration, and length/truthiness operations.</p> <p>Initialize the list with optional items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of items to initialize the list with. If None, creates an empty list.</p> <code>None</code> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None) -&gt; None:\n    \"\"\"Initialize the list with optional items.\n\n    Args:\n        items: Optional iterable of items to initialize the list with.\n            If None, creates an empty list.\n    \"\"\"\n    self._head: _Node[T] | None = None\n    self._tail: _Node[T] | None = None\n    self._length: int = 0\n    for item in items or []:\n        self.append(item)\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList-functions","title":"Functions","text":""},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.append","title":"append","text":"<pre><code>append(value: T) -&gt; None\n</code></pre> <p>Add a value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to append to the list.</p> required <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def append(self, value: T) -&gt; None:\n    \"\"\"Add a value to the end of the list.\n\n    Args:\n        value: The value to append to the list.\n\n    Time complexity: O(n).\n    \"\"\"\n    new_node = _Node(value=value)\n    if self._head is None:\n        self._head = self._tail = new_node\n    else:\n        self._tail.next = new_node\n        self._tail = new_node\n    self._length += 1\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.prepend","title":"prepend","text":"<pre><code>prepend(value: T) -&gt; None\n</code></pre> <p>Add a value to the beginning of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to prepend to the list.</p> required <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def prepend(self, value: T) -&gt; None:\n    \"\"\"Add a value to the beginning of the list.\n\n    Args:\n        value: The value to prepend to the list.\n\n    Time complexity: O(1).\n    \"\"\"\n    new_node = _Node(value=value)\n    if self._head is None:\n        self._head = self._tail = new_node\n    else:\n        new_node.next = self._head\n        self._head = new_node\n    self._length += 1\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.insert","title":"insert","text":"<pre><code>insert(index: int, value: T) -&gt; None\n</code></pre> <p>Insert a value at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>0-based index, negative indexes supported (Python style).</p> required <code>value</code> <code>T</code> <p>The value to insert.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def insert(self, index: int, value: T) -&gt; None:\n    \"\"\"Insert a value at a specific index.\n\n    Args:\n        index: 0-based index, negative indexes supported (Python style).\n        value: The value to insert.\n\n    Raises:\n        IndexError: If index is out of bounds.\n\n    Time complexity: O(n).\n    \"\"\"\n    index = self._get_positive_index(index) + int(index &lt; 0)\n    if index &lt; 0 or index &gt; self._length:\n        raise IndexError('index out of bounds on list')\n    if index == 0:\n        self.prepend(value)\n    elif index == self._length:\n        self.append(value)\n    else:\n        new_node = _Node(value=value)\n        prev = self._get_node_at(index - 1)\n        new_node.next = prev.next\n        prev.next = new_node\n        self._length += 1\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.remove","title":"remove","text":"<pre><code>remove(value: T) -&gt; None\n</code></pre> <p>Remove the first occurrence of <code>value</code> from the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to remove from the list.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not found.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def remove(self, value: T) -&gt; None:\n    \"\"\"Remove the first occurrence of `value` from the list.\n\n    Args:\n        value: The value to remove from the list.\n\n    Raises:\n        ValueError: If the value is not found.\n\n    Time complexity: O(n).\n    \"\"\"\n    prev, curr = None, self._head\n    while curr and curr.value != value:\n        prev = curr\n        curr = curr.next\n    if not curr or curr.value != value:\n        raise ValueError('value not found')\n\n    if prev:\n        prev.next = curr.next\n        if curr == self._tail:\n            self._tail = prev\n    else:\n        self._head = self._head.next\n        if self._head is None:\n            self._tail = None\n    self._length -= 1\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.pop","title":"pop","text":"<pre><code>pop(index: int = -1) -&gt; T\n</code></pre> <p>Remove and return the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>0-based index, negative indexes supported (Python style). Defaults to -1 (last element).</p> <code>-1</code> <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the list is empty or index is invalid.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def pop(self, index: int = -1) -&gt; T:\n    \"\"\"Remove and return the item at the given index.\n\n    Args:\n        index: 0-based index, negative indexes supported (Python style).\n            Defaults to -1 (last element).\n\n    Returns:\n        The value at the specified index.\n\n    Raises:\n        IndexError: If the list is empty or index is invalid.\n\n    Time complexity: O(n).\n    \"\"\"\n    idx = self._get_positive_index(index)\n    if idx &lt; 0 or idx &gt;= self._length:\n        raise IndexError('invalid index')\n    try:\n        assert idx - 1 &gt;= 0\n        prev_node = self._get_node_at(idx - 1)\n        value = prev_node.next.value\n        prev_node.next = prev_node.next.next\n        if prev_node.next is None:\n            self._tail = prev_node\n    except AssertionError:\n        value = self._head.value\n        self._head = self._head.next\n        if self._head is None:\n            self._tail = None\n    self._length -= 1\n    return value\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all elements from the list.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all elements from the list.\n\n    Time complexity: O(1).\n    \"\"\"\n    self._head = self._tail = None\n    self._length = 0\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.head","title":"head","text":"<pre><code>head() -&gt; T | None\n</code></pre> <p>Return the first value in the list.</p> <p>Returns:</p> Type Description <code>T | None</code> <p>The first value in the list, or None if the list is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def head(self) -&gt; T | None:\n    \"\"\"Return the first value in the list.\n\n    Returns:\n        The first value in the list, or None if the list is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    return self._head.value if self._head else None\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.tail","title":"tail","text":"<pre><code>tail() -&gt; T | None\n</code></pre> <p>Return the last value in the list.</p> <p>Returns:</p> Type Description <code>T | None</code> <p>The last value in the list, or None if the list is empty.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def tail(self) -&gt; T | None:\n    \"\"\"Return the last value in the list.\n\n    Returns:\n        The last value in the list, or None if the list is empty.\n\n    Time complexity: O(n).\n    \"\"\"\n    return self._tail.value if self._tail else None\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.find","title":"find","text":"<pre><code>find(value: T) -&gt; int\n</code></pre> <p>Return the index of the first occurrence of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the first occurrence of the value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not found in the list.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def find(self, value: T) -&gt; int:\n    \"\"\"Return the index of the first occurrence of a value.\n\n    Args:\n        value: The value to search for.\n\n    Returns:\n        The index of the first occurrence of the value.\n\n    Raises:\n        ValueError: If the value is not found in the list.\n    \"\"\"\n    for i, node_value in enumerate(self):\n        if value == node_value:\n            return i\n    raise ValueError('value not found')\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of elements in the list.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the linked list.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of elements in the list.\n\n    Returns:\n        The number of elements in the linked list.\n    \"\"\"\n    return self._length\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the list.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the list is empty, True otherwise.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the list.\n\n    Returns:\n        False if the list is empty, True otherwise.\n    \"\"\"\n    return self._length &gt; 0\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre> <p>Get the value at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>0-based index, negative indexes supported (Python style).</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __getitem__(self, index: int) -&gt; T:\n    \"\"\"Get the value at the given index.\n\n    Args:\n        index: 0-based index, negative indexes supported (Python style).\n\n    Returns:\n        The value at the specified index.\n\n    Raises:\n        IndexError: If the index is out of range.\n    \"\"\"\n    return self._get_node_at(index).value\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index: int, value: T) -&gt; None\n</code></pre> <p>Set item at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position at which to set the value. 0-based index, negative indexes supported (Python style).</p> required <code>value</code> <code>T</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __setitem__(self, index: int, value: T) -&gt; None:\n    \"\"\"Set item at the specified index.\n\n    Args:\n        index: The position at which to set the value.\n            0-based index, negative indexes supported (Python style).\n        value: The value to set.\n\n    Raises:\n        IndexError: If index is out of bounds.\n\n    Time complexity: O(n).\n    \"\"\"\n    self._get_node_at(index).value = value\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[T]\n</code></pre> <p>Iterate through values in the list.</p> <p>Yields:</p> Type Description <code>T</code> <p>The values in the list from head to tail.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Iterate through values in the list.\n\n    Yields:\n        The values in the list from head to tail.\n    \"\"\"\n    curr = self._head\n    while curr:\n        yield curr.value\n        curr = curr.next\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the linked list.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation showing the class name and list contents.</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the linked list.\n\n    Returns:\n        A string representation showing the class name and list contents.\n    \"\"\"\n    return f'{self.__class__.__name__}({list(self)})'\n</code></pre>"},{"location":"reference/singly-linked-list/#py_ds.datastructures.linked_lists.singly_linked.LinkedList.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the linked list.</p> <p>Returns:</p> Type Description <code>str</code> <p>A visual representation of the linked list.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/linked_lists/singly_linked.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the linked list.\n\n    Returns:\n        A visual representation of the linked list.\n\n    Time complexity: O(n).\n    \"\"\"\n    if not self:\n        return 'HEAD \u2192 TAIL'\n    return 'HEAD \u2192 ' + ' \u2192 '.join(str(item) for item in self) + ' \u2192 TAIL'\n</code></pre>"},{"location":"reference/stack/","title":"Stack","text":""},{"location":"reference/stack/#py_ds.datastructures.stack.Stack","title":"py_ds.datastructures.stack.Stack","text":"<pre><code>Stack(items: Iterable[T] | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A simple LIFO (last-in, first-out) stack.</p> <p>Backed by a dynamic array (Python list). Provides efficient O(1) operations for push, pop, and peek operations.</p> <p>Initialize the stack.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T] | None</code> <p>Optional iterable of initial items. The last item in the    iterable should be considered the \"top\" of the stack.</p> <code>None</code> Example <p>Stack([1, 2, 3])  # 3 is at the top</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def __init__(self, items: Iterable[T] | None = None) -&gt; None:\n    \"\"\"Initialize the stack.\n\n    Args:\n        items: Optional iterable of initial items. The last item in the\n               iterable should be considered the \"top\" of the stack.\n\n    Example:\n        Stack([1, 2, 3])  # 3 is at the top\n    \"\"\"\n    self._items = list(items) if items else []\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack-functions","title":"Functions","text":""},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.push","title":"push","text":"<pre><code>push(item: T) -&gt; None\n</code></pre> <p>Push a single item onto the top of the stack.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to push onto the stack.</p> required <p>Time complexity: O(1) amortized.</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def push(self, item: T) -&gt; None:\n    \"\"\"Push a single item onto the top of the stack.\n\n    Args:\n        item: The item to push onto the stack.\n\n    Time complexity: O(1) amortized.\n    \"\"\"\n    self._items.append(item)\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.pop","title":"pop","text":"<pre><code>pop() -&gt; T\n</code></pre> <p>Remove and return the top item of the stack.</p> <p>Returns:</p> Type Description <code>T</code> <p>The item that was at the top of the stack.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the stack is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def pop(self) -&gt; T:\n    \"\"\"Remove and return the top item of the stack.\n\n    Returns:\n        The item that was at the top of the stack.\n\n    Raises:\n        IndexError: If the stack is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if self.is_empty():\n        raise IndexError('pop from empty stack')\n    return self._items.pop()\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.peek","title":"peek","text":"<pre><code>peek() -&gt; T\n</code></pre> <p>Return the top item of the stack without removing it.</p> <p>Returns:</p> Type Description <code>T</code> <p>The item at the top of the stack.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the stack is empty.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def peek(self) -&gt; T:\n    \"\"\"Return the top item of the stack without removing it.\n\n    Returns:\n        The item at the top of the stack.\n\n    Raises:\n        IndexError: If the stack is empty.\n\n    Time complexity: O(1).\n    \"\"\"\n    if self.is_empty():\n        raise IndexError('peek from empty stack')\n    return self._items[-1]\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the stack is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the stack has no elements, False otherwise.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the stack is empty.\n\n    Returns:\n        True if the stack has no elements, False otherwise.\n\n    Time complexity: O(1).\n    \"\"\"\n    return len(self._items) == 0\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all items from the stack.</p> <p>After this call, is_empty() returns True and len(stack) == 0.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items from the stack.\n\n    After this call, is_empty() returns True and len(stack) == 0.\n\n    Time complexity: O(1).\n    \"\"\"\n    self._items = []\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.extend","title":"extend","text":"<pre><code>extend(items: Iterable[T]) -&gt; None\n</code></pre> <p>Push multiple items onto the stack, in iteration order.</p> <p>The last item of <code>items</code> becomes the new top of the stack.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[T]</code> <p>An iterable of items to push onto the stack.</p> required Example <p>s = Stack([1]) s.extend([2, 3])</p> <p>Time complexity: O(k), where k is the number of items.</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def extend(self, items: Iterable[T]) -&gt; None:\n    \"\"\"Push multiple items onto the stack, in iteration order.\n\n    The last item of `items` becomes the new top of the stack.\n\n    Args:\n        items: An iterable of items to push onto the stack.\n\n    Example:\n        s = Stack([1])\n        s.extend([2, 3])\n        # now stack top is 3\n\n    Time complexity: O(k), where k is the number of items.\n    \"\"\"\n    for item in items:\n        self.push(item)\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.extend--now-stack-top-is-3","title":"now stack top is 3","text":""},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[T]\n</code></pre> <p>Convert the stack to a Python list.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A shallow copy of the stack contents as a list. The last element</p> <code>list[T]</code> <p>of the returned list is the top of the stack.</p> <p>Time complexity: O(n).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def to_list(self) -&gt; list[T]:\n    \"\"\"Convert the stack to a Python list.\n\n    Returns:\n        A shallow copy of the stack contents as a list. The last element\n        of the returned list is the top of the stack.\n\n    Time complexity: O(n).\n    \"\"\"\n    return self._items[::]\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of items in the stack.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items in the stack.</p> <p>Time complexity: O(1).</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the stack.\n\n    Returns:\n        The number of items in the stack.\n\n    Time complexity: O(1).\n    \"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Return the truthiness of the stack.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the stack is empty, True otherwise.</p> <p>Enables: <code>if stack: ...</code></p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return the truthiness of the stack.\n\n    Returns:\n        False if the stack is empty, True otherwise.\n\n    Enables: `if stack: ...`\n    \"\"\"\n    return len(self._items) &gt; 0\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[T]\n</code></pre> <p>Iterate over the items in the stack from top to bottom.</p> <p>Yields:</p> Type Description <code>T</code> <p>Each item in the stack, starting from the top.</p> Example <p>s = Stack([1, 2, 3]) list(s)  # [3, 2, 1]  (top to bottom)</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Iterate over the items in the stack from top to bottom.\n\n    Yields:\n        Each item in the stack, starting from the top.\n\n    Example:\n        s = Stack([1, 2, 3])\n        list(s)  # [3, 2, 1]  (top to bottom)\n    \"\"\"\n    return iter(self._items[::-1])\n</code></pre>"},{"location":"reference/stack/#py_ds.datastructures.stack.Stack.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the stack.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation showing the class name and stack contents.</p> Example <p>Stack([1, 2, 3])</p> Source code in <code>src/py_ds/datastructures/stack.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the stack.\n\n    Returns:\n        A string representation showing the class name and stack contents.\n\n    Example:\n        Stack([1, 2, 3])\n    \"\"\"\n    return f'Stack({self.to_list()})'\n</code></pre>"},{"location":"structures/","title":"Data Structures Overview","text":"<p>This page provides an overview of all data structures implemented in py-ds-academy. Each structure includes detailed documentation, complexity analysis, and usage examples.</p>"},{"location":"structures/#structure-categories","title":"\ud83d\udcca Structure Categories","text":""},{"location":"structures/#linear-structures","title":"Linear Structures","text":"<p>Linear data structures store elements in a sequential manner.</p>"},{"location":"structures/#stack","title":"Stack","text":"<p>A Last-In-First-Out (LIFO) data structure backed by a Python list.</p> <p>Key Operations:</p> <ul> <li><code>push(item)</code> - O(1)</li> <li><code>pop()</code> - O(1)</li> <li><code>peek()</code> - O(1)</li> </ul> <p>Use Cases: Expression evaluation, undo/redo functionality, backtracking algorithms</p>"},{"location":"structures/#queue","title":"Queue","text":"<p>A First-In-First-Out (FIFO) data structure backed by a Python list.</p> <p>Key Operations:</p> <ul> <li><code>enqueue(item)</code> - O(1)</li> <li><code>dequeue()</code> - O(1)</li> <li><code>peek()</code> - O(1)</li> </ul> <p>Use Cases: Task scheduling, breadth-first search, buffering</p>"},{"location":"structures/#linked-lists","title":"Linked Lists","text":"<p>Dynamic data structures that store elements in nodes connected by pointers.</p> <p>Types:</p> <ul> <li>LinkedList - Nodes point to next node only</li> <li>DoublyLinkedList - Nodes point to both next and previous nodes</li> </ul> <p>Key Operations:</p> <ul> <li><code>append(item)</code> - O(1) for both (using tail pointer)</li> <li><code>prepend(item)</code> - O(1) for both</li> <li><code>insert(index, item)</code> - O(n)</li> <li><code>remove(item)</code> - O(n)</li> </ul> <p>Use Cases: Dynamic memory allocation, implementing other data structures</p>"},{"location":"structures/#trees","title":"Trees","text":"<p>Hierarchical data structures with nodes connected by edges.</p>"},{"location":"structures/#binary-tree","title":"Binary Tree","text":"<p>A tree where each node has at most two children.</p> <p>Traversals:</p> <ul> <li>Preorder - O(n)</li> <li>Inorder - O(n)</li> <li>Postorder - O(n)</li> <li>Level-order (BFS) - O(n)</li> </ul> <p>Use Cases: Expression trees, hierarchical data representation</p>"},{"location":"structures/#binary-search-tree","title":"Binary Search Tree","text":"<p>A binary tree with ordering property: left &lt; node &lt; right.</p> <p>Key Operations:</p> <ul> <li><code>insert(item)</code> - O(log n) average, O(n) worst</li> <li><code>remove(item)</code> - O(log n) average, O(n) worst</li> <li><code>search(item)</code> - O(log n) average, O(n) worst</li> </ul> <p>Use Cases: Searching, sorting, range queries</p>"},{"location":"structures/#avl-tree","title":"AVL Tree","text":"<p>A self-balancing binary search tree that maintains height balance.</p> <p>Key Features:</p> <ul> <li>Automatic rebalancing via rotations</li> <li>Guaranteed O(log n) operations</li> <li>Balance factor tracking</li> </ul> <p>Use Cases: When guaranteed O(log n) performance is required</p>"},{"location":"structures/#heaps","title":"Heaps","text":"<p>Complete binary trees that satisfy the heap property.</p>"},{"location":"structures/#heaps_1","title":"Heaps","text":"<p>Priority queue implementations using binary heaps.</p> <p>Types:</p> <ul> <li>MinHeap - Parent \u2264 children</li> <li>MaxHeap - Parent \u2265 children</li> </ul> <p>Key Operations:</p> <ul> <li><code>push(item)</code> - O(log n)</li> <li><code>pop()</code> - O(log n)</li> <li><code>peek()</code> - O(1)</li> </ul> <p>Use Cases: Priority queues, heap sort, scheduling algorithms</p>"},{"location":"structures/#complexity-comparison","title":"\ud83d\udd0d Complexity Comparison","text":"Structure Insert Delete Search Space Stack O(1) O(1) O(n) O(n) Queue O(1) O(1) O(n) O(n) LinkedList O(1)* O(n) O(n) O(n) DoublyLinkedList O(1) O(n) O(n) O(n) BinarySearchTree O(log n) O(log n) O(log n) O(n) AVLTree O(log n) O(log n) O(log n) O(n) Heap O(log n) O(log n) O(n) O(n) <p>*O(1) for append at tail, O(n) for insert at arbitrary position</p>"},{"location":"structures/#choosing-the-right-structure","title":"\ud83c\udfaf Choosing the Right Structure","text":"<ul> <li>Need LIFO? \u2192 Use a Stack</li> <li>Need FIFO? \u2192 Use a Queue</li> <li>Need dynamic size with O(1) append? \u2192 Use a LinkedList or DoublyLinkedList (both support O(1) append)</li> <li>Need sorted data with fast search? \u2192 Use a BinarySearchTree</li> <li>Need guaranteed O(log n) performance? \u2192 Use an AVLTree</li> <li>Need priority-based access? \u2192 Use a Heap</li> </ul>"},{"location":"structures/#next-steps","title":"\ud83d\udcd6 Next Steps","text":"<ul> <li>Explore individual data structure pages for detailed documentation</li> <li>Check out the API Reference for complete method signatures</li> <li>See Getting Started for usage examples</li> </ul>"},{"location":"structures/avl-tree/","title":"AVL Tree","text":"<p>An AVL Tree (named after inventors Adelson-Velsky and Landis) is a self-balancing Binary Search Tree that maintains height balance through automatic rotations.</p>"},{"location":"structures/avl-tree/#overview","title":"Overview","text":"<p>The AVLTree implementation extends BinarySearchTree and guarantees O(log n) time complexity for all operations by maintaining the AVL property: the heights of the two child subtrees of any node differ by at most 1.</p>"},{"location":"structures/avl-tree/#properties","title":"Properties","text":"<ul> <li>AVL Property: For every node, <code>|height(left) - height(right)| \u2264 1</code></li> <li>Balance Factor: <code>balance_factor = height(left) - height(right)</code></li> <li>Automatic Rebalancing: Tree rebalances after insertions and deletions</li> <li>Guaranteed Performance: O(log n) for all operations</li> </ul>"},{"location":"structures/avl-tree/#operations","title":"Operations","text":""},{"location":"structures/avl-tree/#creating-an-avl-tree","title":"Creating an AVL Tree","text":"<pre><code>from py_ds import AVLTree\n\n# Create an empty AVL tree\navl = AVLTree()\n\n# Create an AVL tree from an iterable\navl = AVLTree([1, 2, 3, 4, 5, 6, 7])\n\n# Print the tree structure (visual representation)\nprint(avl)\n# Output:\n#      \u250c\u2500\u2500 7\n#  \u250c\u2500\u2500 6\n#  \u2502   \u2514\u2500\u2500 5\n#  4\n#  \u2502   \u250c\u2500\u2500 3\n#  \u2514\u2500\u2500 2\n#      \u2514\u2500\u2500 1\n</code></pre>"},{"location":"structures/avl-tree/#insertion","title":"Insertion","text":"<pre><code># Insert a value (automatically rebalances)\navl.insert(8)  # O(log n)\n</code></pre>"},{"location":"structures/avl-tree/#deletion","title":"Deletion","text":"<pre><code># Remove a value (automatically rebalances)\navl.remove(4)  # O(log n)\n</code></pre>"},{"location":"structures/avl-tree/#search","title":"Search","text":"<pre><code># Check if value exists\nif 5 in avl:  # O(log n)\n    print(\"Found!\")\n</code></pre>"},{"location":"structures/avl-tree/#all-bst-operations","title":"All BST Operations","text":"<p>All BinarySearchTree operations are available:</p> <pre><code># Min/Max\nmin_val = avl.min()  # O(log n)\nmax_val = avl.max()  # O(log n)\n\n# Traversals\ninorder = list(avl.inorder())\npreorder = list(avl.preorder())\npostorder = list(avl.postorder())\nlevel_order = list(avl.level_order())\n</code></pre>"},{"location":"structures/avl-tree/#rotations","title":"Rotations","text":"<p>AVL trees use rotations to maintain balance:</p>"},{"location":"structures/avl-tree/#left-rotation","title":"Left Rotation","text":"<p>Used when right subtree is taller:</p> <pre><code>    A              B\n   / \\            / \\\n  T1  B    -&gt;    A   C\n     / \\        / \\\n    T2  C      T1 T2\n</code></pre>"},{"location":"structures/avl-tree/#right-rotation","title":"Right Rotation","text":"<p>Used when left subtree is taller:</p> <pre><code>      A          B\n     / \\        / \\\n    B   T3 -&gt;  C   A\n   / \\        /   / \\\n  C   T2     T1  T2 T3\n /\nT1\n</code></pre>"},{"location":"structures/avl-tree/#left-right-rotation","title":"Left-Right Rotation","text":"<p>Used for left-right imbalance:</p> <pre><code>    A            A              C\n   / \\          / \\            / \\\n  B   T4  -&gt;   C   T4   -&gt;    B   A\n / \\          / \\            / \\ / \\\nT1  C        B   T3        T1 T2 T3 T4\n   / \\      / \\\n  T2 T3    T1 T2\n</code></pre>"},{"location":"structures/avl-tree/#right-left-rotation","title":"Right-Left Rotation","text":"<p>Used for right-left imbalance:</p> <pre><code>  A            A              C\n / \\          / \\            / \\\nT1  B   -&gt;   T1  C     -&gt;   A   B\n   / \\          / \\        / \\ / \\\n  C   T4       T2  B      T1 T2 T3 T4\n / \\              / \\\nT2 T3            T3 T4\n</code></pre>"},{"location":"structures/avl-tree/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>insert(item)</code> O(log n) <code>remove(item)</code> O(log n) <code>contains(item)</code> O(log n) <code>min()</code> O(log n) <code>max()</code> O(log n) Traversals O(n) <p>All operations are guaranteed O(log n) - no worst-case degradation to O(n).</p>"},{"location":"structures/avl-tree/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of nodes.</p>"},{"location":"structures/avl-tree/#use-cases","title":"Use Cases","text":"<ul> <li>When Guaranteed Performance Matters - Critical applications requiring O(log n)</li> <li>Real-Time Systems - Predictable performance characteristics</li> <li>Database Indexing - When balanced trees are required</li> <li>Priority Queues - Combined with heap operations</li> <li>Range Queries - Efficient range searches on sorted data</li> </ul>"},{"location":"structures/avl-tree/#example-maintaining-sorted-order","title":"Example: Maintaining Sorted Order","text":"<pre><code>avl = AVLTree([5, 3, 7, 2, 4, 6, 8])\n\n# Tree remains balanced after all operations\navl.insert(1)  # Automatically rebalances\navl.insert(9)  # Automatically rebalances\navl.remove(5)  # Automatically rebalances\n\n# Print the tree structure to see the balanced tree\nprint(avl)\n\n# Height is kept minimal\nprint(avl.height)  # O(log n) height guaranteed\n\n# All operations remain O(log n)\nsorted_values = list(avl.inorder())  # Always sorted\n</code></pre>"},{"location":"structures/avl-tree/#example-comparison-with-bst","title":"Example: Comparison with BST","text":"<pre><code>from py_ds import BinarySearchTree, AVLTree\n\n# Worst case: inserting sorted sequence\nvalues = list(range(1000))\n\n# BST becomes a linked list (O(n) operations)\nbst = BinarySearchTree(values)\nprint(bst.height)  # ~1000 (unbalanced!)\n\n# AVL stays balanced (O(log n) operations)\navl = AVLTree(values)\nprint(avl.height)  # ~10 (balanced!)\n</code></pre>"},{"location":"structures/avl-tree/#balance-factor","title":"Balance Factor","text":"<p>Each node maintains a balance factor:</p> <ul> <li><code>balance_factor = height(left) - height(right)</code></li> <li>Valid values: -1, 0, or 1</li> <li>If balance factor is outside this range, rotation occurs</li> </ul>"},{"location":"structures/avl-tree/#when-to-use-avl-vs-bst","title":"When to Use AVL vs BST","text":"<p>Use AVLTree when:</p> <ul> <li>You need guaranteed O(log n) performance</li> <li>Data insertion order is unpredictable</li> <li>Worst-case performance matters</li> <li>You're inserting/deleting frequently</li> </ul> <p>Use BinarySearchTree when:</p> <ul> <li>Data is inserted in random order</li> <li>Worst-case performance is acceptable</li> <li>Simplicity is preferred</li> <li>Memory overhead is a concern</li> </ul>"},{"location":"structures/binary-search-tree/","title":"Binary Search Tree","text":"<p>A Binary Search Tree (BST) is a binary tree with the ordering property: for any node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value.</p>"},{"location":"structures/binary-search-tree/#overview","title":"Overview","text":"<p>The BinarySearchTree implementation extends BinaryTree and provides efficient search, insert, and delete operations with average O(log n) time complexity.</p>"},{"location":"structures/binary-search-tree/#properties","title":"Properties","text":"<ul> <li>Ordering Property: <code>left &lt; node &lt; right</code> for all nodes</li> <li>No Duplicates: Each value appears at most once (implementation-dependent)</li> <li>Inorder Traversal: Produces sorted sequence</li> </ul>"},{"location":"structures/binary-search-tree/#operations","title":"Operations","text":""},{"location":"structures/binary-search-tree/#creating-a-bst","title":"Creating a BST","text":"<pre><code>from py_ds import BinarySearchTree\n\n# Create an empty BST\nbst = BinarySearchTree()\n\n# Create a BST from an iterable\nbst = BinarySearchTree([5, 3, 7, 2, 4, 6, 8])\n\n# Print the tree structure (visual representation)\nprint(bst)\n# Output:\n#      \u250c\u2500\u2500 8\n#  \u250c\u2500\u2500 7\n#  \u2502   \u2514\u2500\u2500 6\n#  5\n#  \u2502   \u250c\u2500\u2500 4\n#  \u2514\u2500\u2500 3\n#      \u2514\u2500\u2500 2\n</code></pre>"},{"location":"structures/binary-search-tree/#insertion","title":"Insertion","text":"<pre><code># Insert a value\nbst.insert(9)  # O(log n) average, O(n) worst case\n</code></pre>"},{"location":"structures/binary-search-tree/#search","title":"Search","text":"<pre><code># Check if value exists\nif 4 in bst:  # O(log n) average, O(n) worst case\n    print(\"Found!\")\n\n# Or use contains method\nif bst.contains(4):\n    print(\"Found!\")\n</code></pre>"},{"location":"structures/binary-search-tree/#deletion","title":"Deletion","text":"<pre><code># Remove a value\nbst.remove(3)  # O(log n) average, O(n) worst case\n</code></pre>"},{"location":"structures/binary-search-tree/#finding-minmax","title":"Finding Min/Max","text":"<pre><code># Find minimum value\nmin_val = bst.min()  # O(log n) average, O(n) worst case\n\n# Find maximum value\nmax_val = bst.max()  # O(log n) average, O(n) worst case\n</code></pre>"},{"location":"structures/binary-search-tree/#traversals","title":"Traversals","text":"<p>All BinaryTree traversals are available:</p> <pre><code># Inorder (produces sorted sequence)\nsorted_values = list(bst.inorder())\n\n# Preorder\npreorder_values = list(bst.preorder())\n\n# Postorder\npostorder_values = list(bst.postorder())\n\n# Level-order (BFS)\nlevel_order_values = list(bst.level_order())\n</code></pre>"},{"location":"structures/binary-search-tree/#time-complexity","title":"Time Complexity","text":"Operation Average Worst Case <code>insert(item)</code> O(log n) O(n) <code>remove(item)</code> O(log n) O(n) <code>contains(item)</code> O(log n) O(n) <code>min()</code> O(log n) O(n) <code>max()</code> O(log n) O(n) Traversals O(n) O(n) <p>Note</p> <p>Worst case occurs when the tree becomes a linked list (unbalanced).</p>"},{"location":"structures/binary-search-tree/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of nodes.</p>"},{"location":"structures/binary-search-tree/#use-cases","title":"Use Cases","text":"<ul> <li>Sorted Data Storage - Maintaining sorted order efficiently</li> <li>Range Queries - Finding all values in a range</li> <li>Symbol Tables - Key-value mappings</li> <li>Priority Queues - When combined with heap operations</li> <li>Database Indexing - B-trees are based on BST concepts</li> </ul>"},{"location":"structures/binary-search-tree/#example-sorted-data-storage","title":"Example: Sorted Data Storage","text":"<pre><code>bst = BinarySearchTree([5, 3, 7, 2, 4, 6, 8])\n\n# Print the tree structure\nprint(bst)\n\n# Get sorted values\nsorted_data = list(bst.inorder())  # [2, 3, 4, 5, 6, 7, 8]\n\n# Find values in range\ndef range_query(bst, low, high):\n    result = []\n    for value in bst.inorder():\n        if low &lt;= value &lt;= high:\n            result.append(value)\n        elif value &gt; high:\n            break\n    return result\n\nvalues = range_query(bst, 3, 6)  # [3, 4, 5, 6]\n</code></pre>"},{"location":"structures/binary-search-tree/#example-symbol-table","title":"Example: Symbol Table","text":"<pre><code>class SymbolTable:\n    def __init__(self):\n        self.bst = BinarySearchTree()\n        self.data = {}\n\n    def put(self, key, value):\n        self.bst.insert(key)\n        self.data[key] = value\n\n    def get(self, key):\n        if key in self.bst:\n            return self.data.get(key)\n        return None\n\n    def keys(self):\n        return list(self.bst.inorder())\n</code></pre>"},{"location":"structures/binary-search-tree/#deletion-cases","title":"Deletion Cases","text":"<p>The <code>remove</code> operation handles three cases:</p> <ol> <li>Node with no children - Simply remove the node</li> <li>Node with one child - Replace node with its child</li> <li>Node with two children - Replace with inorder successor/predecessor</li> </ol>"},{"location":"structures/binary-search-tree/#balancing","title":"Balancing","text":"<p>For guaranteed O(log n) performance, consider using AVLTree which automatically maintains balance.</p>"},{"location":"structures/binary-tree/","title":"Binary Tree","text":"<p>A Binary Tree is a hierarchical data structure where each node has at most two children, referred to as the left child and right child.</p>"},{"location":"structures/binary-tree/#overview","title":"Overview","text":"<p>The BinaryTree implementation in py-ds-academy provides a generic base class for binary tree structures, supporting multiple traversal methods and tree operations.</p>"},{"location":"structures/binary-tree/#structure","title":"Structure","text":"<p>Each node contains:</p> <ul> <li><code>value</code> - The data stored in the node</li> <li><code>left</code> - Reference to the left child (or None)</li> <li><code>right</code> - Reference to the right child (or None)</li> </ul>"},{"location":"structures/binary-tree/#traversals","title":"Traversals","text":"<p>Binary trees can be traversed in several ways:</p>"},{"location":"structures/binary-tree/#preorder-traversal","title":"Preorder Traversal","text":"<p>Visit: Root \u2192 Left \u2192 Right</p> <pre><code>from py_ds import BinarySearchTree\n\ntree = BinarySearchTree([5, 3, 7, 2, 4])\n\nfor value in tree.preorder():\n    print(value)  # 5, 3, 2, 4, 7\n</code></pre>"},{"location":"structures/binary-tree/#inorder-traversal","title":"Inorder Traversal","text":"<p>Visit: Left \u2192 Root \u2192 Right</p> <pre><code>for value in tree.inorder():\n    print(value)  # 2, 3, 4, 5, 7\n</code></pre>"},{"location":"structures/binary-tree/#postorder-traversal","title":"Postorder Traversal","text":"<p>Visit: Left \u2192 Right \u2192 Root</p> <pre><code>for value in tree.postorder():\n    print(value)  # 2, 4, 3, 7, 5\n</code></pre>"},{"location":"structures/binary-tree/#level-order-traversal-bfs","title":"Level-Order Traversal (BFS)","text":"<p>Visit nodes level by level, left to right:</p> <pre><code>for value in tree.level_order():\n    print(value)  # 5, 3, 7, 2, 4\n</code></pre>"},{"location":"structures/binary-tree/#operations","title":"Operations","text":""},{"location":"structures/binary-tree/#tree-height","title":"Tree Height","text":"<pre><code>height = tree.height  # O(n)\n</code></pre>"},{"location":"structures/binary-tree/#tree-visualization","title":"Tree Visualization","text":"<pre><code>from py_ds import BinarySearchTree\n\ntree = BinarySearchTree([5, 3, 7, 2, 4])\n\n# Print the tree structure (visual representation)\nprint(tree)\n# Output:\n#  \u250c\u2500\u2500 7\n#  5\n#  \u2502   \u250c\u2500\u2500 4\n#  \u2514\u2500\u2500 3\n#      \u2514\u2500\u2500 2\n</code></pre>"},{"location":"structures/binary-tree/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>preorder()</code> O(n) <code>inorder()</code> O(n) <code>postorder()</code> O(n) <code>level_order()</code> O(n) <code>height</code> O(n)"},{"location":"structures/binary-tree/#space-complexity","title":"Space Complexity","text":"<ul> <li>Traversals: O(h) where h is the height of the tree</li> <li>Storage: O(n) where n is the number of nodes</li> </ul>"},{"location":"structures/binary-tree/#use-cases","title":"Use Cases","text":"<ul> <li>Expression Trees - Representing mathematical expressions</li> <li>Hierarchical Data - File systems, organization charts</li> <li>Decision Trees - Machine learning and AI</li> <li>Syntax Trees - Compiler design</li> <li>Base for Specialized Trees - BST, AVL, etc.</li> </ul>"},{"location":"structures/binary-tree/#example-expression-tree","title":"Example: Expression Tree","text":"<pre><code># Represent: (3 + 4) * 2\n#        *\n#       / \\\n#      +   2\n#     / \\\n#    3   4\n\nfrom py_ds.datastructures.trees.base import BinaryTree, _BinaryNode\n\n# Create a simple concrete class for building expression trees\nclass ExpressionTree(BinaryTree):\n    \"\"\"A simple binary tree for building expression trees manually.\"\"\"\n\n    def insert(self, value):\n        \"\"\"Not used for expression trees - we build manually.\"\"\"\n        pass\n\n    def remove(self, value):\n        \"\"\"Not used for expression trees.\"\"\"\n        pass\n\n# Build the expression tree manually\ntree = ExpressionTree()\ntree._root = _BinaryNode('*')\ntree._root.left = _BinaryNode('+')\ntree._root.right = _BinaryNode(2)\ntree._root.left.left = _BinaryNode(3)\ntree._root.left.right = _BinaryNode(4)\ntree.size = 5  # Update size manually\n\n# Print the tree structure\nprint(tree)\n# Output:\n#  \u250c\u2500\u2500 2\n#  *\n#  \u2502   \u250c\u2500\u2500 4\n#  \u2514\u2500\u2500 +\n#      \u2514\u2500\u2500 3\n\n# Evaluate using postorder traversal\ndef evaluate(node):\n    if isinstance(node.value, (int, float)):\n        return node.value\n\n    left_val = evaluate(node.left)\n    right_val = evaluate(node.right)\n\n    if node.value == '+':\n        return left_val + right_val\n    elif node.value == '-':\n        return left_val - right_val\n    elif node.value == '*':\n        return left_val * right_val\n    elif node.value == '/':\n        return left_val / right_val\n\nresult = evaluate(tree._root)  # 14\nprint(f\"Result: {result}\")  # Result: 14\n</code></pre>"},{"location":"structures/binary-tree/#example-tree-traversal","title":"Example: Tree Traversal","text":"<pre><code>from py_ds import BinarySearchTree\n\n# Create a binary search tree\ntree = BinarySearchTree([5, 3, 7, 2, 4, 6, 8])\n\n# Print the tree structure\nprint(tree)\n# Output:\n#      \u250c\u2500\u2500 8\n#  \u250c\u2500\u2500 7\n#  \u2502   \u2514\u2500\u2500 6\n#  5\n#  \u2502   \u250c\u2500\u2500 4\n#  \u2514\u2500\u2500 3\n#      \u2514\u2500\u2500 2\n\n# Get tree height\nprint(tree.height)  # 2\n\n# Traverse in different orders\nprint(list(tree.preorder()))   # [5, 3, 2, 4, 7, 6, 8]\nprint(list(tree.inorder()))    # [2, 3, 4, 5, 6, 7, 8]\nprint(list(tree.postorder()))  # [2, 4, 3, 6, 8, 7, 5]\nprint(list(tree.level_order())) # [5, 3, 7, 2, 4, 6, 8]\n</code></pre>"},{"location":"structures/heaps/","title":"Heaps","text":"<p>A Heap is a complete binary tree that satisfies the heap property. Heaps are commonly used to implement priority queues.</p>"},{"location":"structures/heaps/#overview","title":"Overview","text":"<p>py-ds-academy provides two heap implementations:</p> <ul> <li>MinHeap - Parent nodes are always less than or equal to their children</li> <li>MaxHeap - Parent nodes are always greater than or equal to their children</li> </ul>"},{"location":"structures/heaps/#heap-property","title":"Heap Property","text":""},{"location":"structures/heaps/#minheap-property","title":"MinHeap Property","text":"<p>For every node <code>i</code> (except root): - <code>parent(i) \u2264 node(i)</code> - Smallest element is always at the root</p>"},{"location":"structures/heaps/#maxheap-property","title":"MaxHeap Property","text":"<p>For every node <code>i</code> (except root): - <code>parent(i) \u2265 node(i)</code> - Largest element is always at the root</p>"},{"location":"structures/heaps/#operations","title":"Operations","text":""},{"location":"structures/heaps/#creating-a-heap","title":"Creating a Heap","text":"<pre><code>from py_ds import MinHeap, MaxHeap\n\n# Create an empty heap\nmin_heap = MinHeap()\nmax_heap = MaxHeap()\n\n# Create a heap from an iterable\nmin_heap = MinHeap([3, 1, 4, 1, 5])\nmax_heap = MaxHeap([3, 1, 4, 1, 5])\n</code></pre>"},{"location":"structures/heaps/#adding-elements","title":"Adding Elements","text":"<pre><code># Push an item onto the heap\nmin_heap.push(2)  # O(log n)\nmax_heap.push(10)  # O(log n)\n</code></pre>"},{"location":"structures/heaps/#removing-elements","title":"Removing Elements","text":"<pre><code># Pop and return the root (min for MinHeap, max for MaxHeap)\nmin_item = min_heap.pop()  # O(log n)\nmax_item = max_heap.pop()  # O(log n)\n</code></pre>"},{"location":"structures/heaps/#accessing-elements","title":"Accessing Elements","text":"<pre><code># Peek at the root without removing\nmin_val = min_heap.peek()  # O(1)\nmax_val = max_heap.peek()  # O(1)\n</code></pre>"},{"location":"structures/heaps/#utility-methods","title":"Utility Methods","text":"<pre><code># Check if heap is empty\nis_empty = min_heap.is_empty()  # O(1)\n\n# Get the number of elements\nlength = len(min_heap)  # O(1)\n\n# Convert to list (not sorted!)\nitems = min_heap.to_list()  # O(n)\n</code></pre>"},{"location":"structures/heaps/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>push(item)</code> O(log n) <code>pop()</code> O(log n) <code>peek()</code> O(1) <code>is_empty()</code> O(1) <code>__len__()</code> O(1) <code>to_list()</code> O(n) Construction from iterable O(n)"},{"location":"structures/heaps/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of elements.</p>"},{"location":"structures/heaps/#use-cases","title":"Use Cases","text":"<ul> <li>Priority Queues - Task scheduling, event simulation</li> <li>Heap Sort - Efficient sorting algorithm</li> <li>Top-K Problems - Finding k largest/smallest elements</li> <li>Median Finding - Using two heaps</li> <li>Dijkstra's Algorithm - Shortest path finding</li> </ul>"},{"location":"structures/heaps/#example-priority-queue","title":"Example: Priority Queue","text":"<pre><code>class Task:\n    def __init__(self, priority, name):\n        self.priority = priority\n        self.name = name\n\n    def __lt__(self, other):\n        return self.priority &lt; other.priority\n\n    def __repr__(self):\n        return f\"Task({self.priority}, {self.name})\"\n\n# MinHeap for priority queue (lower number = higher priority)\npq = MinHeap([\n    Task(3, \"Low priority\"),\n    Task(1, \"High priority\"),\n    Task(2, \"Medium priority\")\n])\n\n# Process tasks in priority order\nwhile not pq.is_empty():\n    task = pq.pop()\n    print(f\"Processing: {task.name}\")\n</code></pre>"},{"location":"structures/heaps/#example-top-k-elements","title":"Example: Top-K Elements","text":"<pre><code>def find_top_k_largest(items, k):\n    \"\"\"Find k largest elements using MinHeap.\"\"\"\n    min_heap = MinHeap()\n\n    for item in items:\n        if len(min_heap) &lt; k:\n            min_heap.push(item)\n        elif item &gt; min_heap.peek():\n            min_heap.pop()\n            min_heap.push(item)\n\n    # Return in descending order\n    result = []\n    while not min_heap.is_empty():\n        result.append(min_heap.pop())\n    return result[::-1]\n\ntop_3 = find_top_k_largest([1, 5, 3, 9, 2, 7, 4, 8], 3)\n# Returns [9, 8, 7]\n</code></pre>"},{"location":"structures/heaps/#example-heap-sort","title":"Example: Heap Sort","text":"<pre><code>def heap_sort(items):\n    \"\"\"Sort items using heap.\"\"\"\n    heap = MinHeap(items)\n    result = []\n\n    while not heap.is_empty():\n        result.append(heap.pop())\n\n    return result\n\nsorted_items = heap_sort([3, 1, 4, 1, 5, 9, 2, 6])\n# Returns [1, 1, 2, 3, 4, 5, 6, 9]\n</code></pre>"},{"location":"structures/heaps/#example-finding-median","title":"Example: Finding Median","text":"<pre><code>class MedianFinder:\n    def __init__(self):\n        # MaxHeap for lower half (largest at root)\n        self.lower = MaxHeap()\n        # MinHeap for upper half (smallest at root)\n        self.upper = MinHeap()\n\n    def add(self, num):\n        if self.lower.is_empty() or num &lt;= self.lower.peek():\n            self.lower.push(num)\n        else:\n            self.upper.push(num)\n\n        # Balance heaps\n        if len(self.lower) &gt; len(self.upper) + 1:\n            self.upper.push(self.lower.pop())\n        elif len(self.upper) &gt; len(self.lower) + 1:\n            self.lower.push(self.upper.pop())\n\n    def find_median(self):\n        if len(self.lower) == len(self.upper):\n            return (self.lower.peek() + self.upper.peek()) / 2\n        elif len(self.lower) &gt; len(self.upper):\n            return self.lower.peek()\n        else:\n            return self.upper.peek()\n</code></pre>"},{"location":"structures/heaps/#internal-structure","title":"Internal Structure","text":"<p>Heaps are typically implemented using arrays:</p> <ul> <li>Parent of node at index <code>i</code>: <code>(i - 1) // 2</code></li> <li>Left child of node at index <code>i</code>: <code>2 * i + 1</code></li> <li>Right child of node at index <code>i</code>: <code>2 * i + 2</code></li> </ul>"},{"location":"structures/heaps/#heap-operations","title":"Heap Operations","text":""},{"location":"structures/heaps/#heapify-up-bubble-up","title":"Heapify Up (Bubble Up)","text":"<p>After inserting, move element up until heap property is satisfied:</p> <pre><code>def heapify_up(heap, index):\n    parent = (index - 1) // 2\n    if parent &gt;= 0 and heap[parent] &gt; heap[index]:\n        heap[parent], heap[index] = heap[index], heap[parent]\n        heapify_up(heap, parent)\n</code></pre>"},{"location":"structures/heaps/#heapify-down-bubble-down","title":"Heapify Down (Bubble Down)","text":"<p>After removing root, move element down until heap property is satisfied:</p> <pre><code>def heapify_down(heap, index):\n    left = 2 * index + 1\n    right = 2 * index + 2\n    smallest = index\n\n    if left &lt; len(heap) and heap[left] &lt; heap[smallest]:\n        smallest = left\n    if right &lt; len(heap) and heap[right] &lt; heap[smallest]:\n        smallest = right\n\n    if smallest != index:\n        heap[index], heap[smallest] = heap[smallest], heap[index]\n        heapify_down(heap, smallest)\n</code></pre>"},{"location":"structures/linked-lists/","title":"Linked Lists","text":"<p>Linked Lists are dynamic data structures that store elements in nodes connected by pointers. Unlike arrays, linked lists don't require contiguous memory allocation.</p>"},{"location":"structures/linked-lists/#overview","title":"Overview","text":"<p>py-ds-academy provides two implementations:</p> <ul> <li>LinkedList - Each node points only to the next node</li> <li>DoublyLinkedList - Each node points to both next and previous nodes</li> </ul>"},{"location":"structures/linked-lists/#linked-list","title":"Linked List","text":"<p>A linear data structure where each node contains data and a reference to the next node.</p>"},{"location":"structures/linked-lists/#operations","title":"Operations","text":"<pre><code>from py_ds import LinkedList\n\n# Create a linked list\nsll = LinkedList([1, 2, 3])\n\n# Append at the end\nsll.append(4)  # O(1) - uses tail pointer\n\n# Prepend at the beginning\nsll.prepend(0)  # O(1)\n\n# Insert at index\nsll.insert(2, 99)  # O(n)\n\n# Remove by value\nsll.remove(2)  # O(n)\n\n# Pop from end\nitem = sll.pop()  # O(n)\n\n# Find an element\nnode = sll.find(3)  # O(n)\n\n# Access by index\nvalue = sll[0]  # O(n)\nsll[0] = 10  # O(n)\n\n# Get head and tail\nhead = sll.head()\ntail = sll.tail()\n\n# Print the linked list (visual representation)\nprint(sll)  # HEAD \u2192 10 \u2192 1 \u2192 99 \u2192 3 \u2192 TAIL\n\n# Clear all nodes\nsll.clear()\n</code></pre>"},{"location":"structures/linked-lists/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>append(item)</code> O(1) <code>prepend(item)</code> O(1) <code>insert(index, item)</code> O(n) <code>remove(item)</code> O(n) <code>pop()</code> O(n) <code>find(item)</code> O(n) <code>__getitem__(index)</code> O(n) <code>__setitem__(index, item)</code> O(n) <code>head()</code> O(1) <code>tail()</code> O(1)"},{"location":"structures/linked-lists/#doubly-linked-list","title":"Doubly Linked List","text":"<p>A linked list where each node contains references to both next and previous nodes, enabling efficient bidirectional traversal.</p>"},{"location":"structures/linked-lists/#operations_1","title":"Operations","text":"<pre><code>from py_ds import DoublyLinkedList\n\n# Create a doubly linked list\ndll = DoublyLinkedList([1, 2, 3])\n\n# Append at the end (O(1) with tail pointer!)\ndll.append(4)  # O(1)\n\n# Prepend at the beginning\ndll.prepend(0)  # O(1)\n\n# Insert at index\ndll.insert(2, 99)  # O(n) - optimized with bidirectional search\n\n# Remove by value\ndll.remove(2)  # O(n)\n\n# Pop from end\nitem = dll.pop()  # O(1)\n\n# Find an element\nnode = dll.find(3)  # O(n)\n\n# Access by index (optimized)\nvalue = dll[0]  # O(n) - but uses bidirectional search\ndll[0] = 10  # O(n)\n\n# Forward iteration\nfor item in dll:\n    print(item)\n\n# Reverse iteration\nfor item in dll.reverse_iter():\n    print(item)\n\n# Get head and tail\nhead = dll.head()\ntail = dll.tail()  # O(1)\n\n# Print the doubly linked list (visual representation)\nprint(dll)  # HEAD \u21c6 10 \u2192 1 \u21c6 99 \u21c6 3 \u21c6 TAIL\n</code></pre>"},{"location":"structures/linked-lists/#time-complexity_1","title":"Time Complexity","text":"Operation Time Complexity <code>append(item)</code> O(1) <code>prepend(item)</code> O(1) <code>insert(index, item)</code> O(n) \u26a1 <code>remove(item)</code> O(n) <code>pop(index)</code> O(n) \u26a1 <code>find(item)</code> O(n) <code>__getitem__(index)</code> O(n) \u26a1 <code>__setitem__(index, item)</code> O(n) \u26a1 <code>head()</code> O(1) <code>tail()</code> O(1) <code>reverse_iter()</code> O(n) <p>\u26a1 = Advantage over singly linked list</p>"},{"location":"structures/linked-lists/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of elements. DoublyLinkedList uses slightly more memory due to the extra pointer per node.</p>"},{"location":"structures/linked-lists/#use-cases","title":"Use Cases","text":"<ul> <li>Dynamic Memory Allocation - When size is unknown at compile time</li> <li>Implementing Other Structures - Stacks, queues, deques</li> <li>Insertion/Deletion Heavy - When frequent insertions/deletions are needed</li> <li>Undo/Redo - DoublyLinkedList enables efficient backward traversal</li> <li>Browser History - Forward/backward navigation</li> </ul>"},{"location":"structures/linked-lists/#example-implementing-a-stack-with-linked-list","title":"Example: Implementing a Stack with Linked List","text":"<pre><code>class LinkedListStack:\n    def __init__(self):\n        self._list = LinkedList()\n\n    def push(self, item):\n        self._list.prepend(item)\n\n    def pop(self):\n        if self._list.head() is None:\n            raise IndexError(\"Stack is empty\")\n        return self._list.pop(0)\n\n    def peek(self):\n        head = self._list.head()\n        if head is None:\n            raise IndexError(\"Stack is empty\")\n        return head.value\n</code></pre>"},{"location":"structures/linked-lists/#example-browser-history","title":"Example: Browser History","text":"<pre><code>class BrowserHistory:\n    def __init__(self):\n        self.history = DoublyLinkedList()\n        self.current = None\n\n    def visit(self, url):\n        if self.current:\n            # Remove all forward history\n            while self.history.tail() != self.current:\n                self.history.pop()\n        self.history.append(url)\n        self.current = self.history.tail()\n\n    def back(self):\n        if self.current and self.current.prev:\n            self.current = self.current.prev\n            return self.current.value\n        return None\n\n    def forward(self):\n        if self.current and self.current.next:\n            self.current = self.current.next\n            return self.current.value\n        return None\n</code></pre>"},{"location":"structures/linked-lists/#when-to-use-which","title":"When to Use Which?","text":"<p>Use LinkedList when:</p> <ul> <li>You only need forward traversal</li> <li>Memory is a concern</li> <li>You're implementing a simple stack or queue</li> </ul> <p>Use DoublyLinkedList when:</p> <ul> <li>You need bidirectional traversal</li> <li>You're implementing undo/redo functionality</li> <li>You need efficient reverse iteration</li> </ul>"},{"location":"structures/queue/","title":"Queue","text":"<p>A Queue is a First-In-First-Out (FIFO) data structure where elements are added at one end (rear) and removed from the other end (front).</p>"},{"location":"structures/queue/#overview","title":"Overview","text":"<p>The Queue implementation in py-ds-academy is backed by a Python list, providing O(1) enqueue and dequeue operations.</p>"},{"location":"structures/queue/#operations","title":"Operations","text":""},{"location":"structures/queue/#creating-a-queue","title":"Creating a Queue","text":"<pre><code>from py_ds import Queue\n\n# Create an empty queue\nqueue = Queue()\n\n# Create a queue from an iterable\nqueue = Queue([1, 2, 3])\n</code></pre>"},{"location":"structures/queue/#adding-elements","title":"Adding Elements","text":"<pre><code># Enqueue an item at the rear\nqueue.enqueue(4)  # O(1)\n</code></pre>"},{"location":"structures/queue/#removing-elements","title":"Removing Elements","text":"<pre><code># Dequeue and return the front item\nitem = queue.dequeue()  # O(1), raises IndexError if empty\n</code></pre>"},{"location":"structures/queue/#accessing-elements","title":"Accessing Elements","text":"<pre><code># Peek at the front without removing\nfront = queue.peek()  # O(1), raises IndexError if empty\n</code></pre>"},{"location":"structures/queue/#utility-methods","title":"Utility Methods","text":"<pre><code># Check if queue is empty\nis_empty = queue.is_empty()  # O(1)\n\n# Get the number of elements\nlength = len(queue)  # O(1)\n\n# Clear all elements\nqueue.clear()  # O(1)\n\n# Convert to list\nitems = queue.to_list()  # O(n)\n\n# Extend with multiple items\nqueue.extend([5, 6, 7])  # O(k) where k is number of items\n</code></pre>"},{"location":"structures/queue/#iteration","title":"Iteration","text":"<pre><code># Iterate over queue (from front to rear)\nfor item in queue:\n    print(item)\n\n# Convert to list\nitems = list(queue)\n</code></pre>"},{"location":"structures/queue/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>enqueue(item)</code> O(1) <code>dequeue()</code> O(1) <code>peek()</code> O(1) <code>is_empty()</code> O(1) <code>__len__()</code> O(1) <code>clear()</code> O(1) <code>to_list()</code> O(n) <code>extend(items)</code> O(k) <code>__iter__()</code> O(n)"},{"location":"structures/queue/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of elements stored.</p>"},{"location":"structures/queue/#use-cases","title":"Use Cases","text":"<ul> <li>Task Scheduling - Processing tasks in order</li> <li>Breadth-First Search - Level-order tree/graph traversal</li> <li>Buffering - Managing data streams</li> <li>Print Queue - Managing print jobs</li> <li>Message Queues - Inter-process communication</li> </ul>"},{"location":"structures/queue/#example-breadth-first-search","title":"Example: Breadth-First Search","text":"<pre><code>def bfs_level_order(tree):\n    if not tree.root:\n        return []\n\n    queue = Queue([tree.root])\n    result = []\n\n    while not queue.is_empty():\n        node = queue.dequeue()\n        result.append(node.value)\n\n        if node.left:\n            queue.enqueue(node.left)\n        if node.right:\n            queue.enqueue(node.right)\n\n    return result\n</code></pre>"},{"location":"structures/queue/#example-task-scheduler","title":"Example: Task Scheduler","text":"<pre><code>class TaskScheduler:\n    def __init__(self):\n        self.queue = Queue()\n\n    def add_task(self, task):\n        self.queue.enqueue(task)\n\n    def process_next(self):\n        if not self.queue.is_empty():\n            task = self.queue.dequeue()\n            task.execute()\n            return task\n        return None\n\n    def has_pending_tasks(self):\n        return not self.queue.is_empty()\n</code></pre>"},{"location":"structures/stack/","title":"Stack","text":"<p>A Stack is a Last-In-First-Out (LIFO) data structure where elements are added and removed from the same end (the \"top\").</p>"},{"location":"structures/stack/#overview","title":"Overview","text":"<p>The Stack implementation in py-ds-academy is backed by a Python list, providing O(1) push and pop operations.</p>"},{"location":"structures/stack/#operations","title":"Operations","text":""},{"location":"structures/stack/#creating-a-stack","title":"Creating a Stack","text":"<pre><code>from py_ds import Stack\n\n# Create an empty stack\nstack = Stack()\n\n# Create a stack from an iterable\nstack = Stack([1, 2, 3])\n</code></pre>"},{"location":"structures/stack/#adding-elements","title":"Adding Elements","text":"<pre><code># Push an item onto the stack\nstack.push(4)  # O(1)\n</code></pre>"},{"location":"structures/stack/#removing-elements","title":"Removing Elements","text":"<pre><code># Pop and return the top item\nitem = stack.pop()  # O(1), raises IndexError if empty\n</code></pre>"},{"location":"structures/stack/#accessing-elements","title":"Accessing Elements","text":"<pre><code># Peek at the top without removing\ntop = stack.peek()  # O(1), raises IndexError if empty\n</code></pre>"},{"location":"structures/stack/#utility-methods","title":"Utility Methods","text":"<pre><code># Check if stack is empty\nis_empty = stack.is_empty()  # O(1)\n\n# Get the number of elements\nlength = len(stack)  # O(1)\n\n# Clear all elements\nstack.clear()  # O(1)\n\n# Convert to list\nitems = stack.to_list()  # O(n)\n\n# Extend with multiple items\nstack.extend([5, 6, 7])  # O(k) where k is number of items\n</code></pre>"},{"location":"structures/stack/#iteration","title":"Iteration","text":"<pre><code># Iterate over stack (from top to bottom)\nfor item in stack:\n    print(item)\n\n# Convert to list\nitems = list(stack)\n</code></pre>"},{"location":"structures/stack/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity <code>push(item)</code> O(1) <code>pop()</code> O(1) <code>peek()</code> O(1) <code>is_empty()</code> O(1) <code>__len__()</code> O(1) <code>clear()</code> O(1) <code>to_list()</code> O(n) <code>extend(items)</code> O(k) <code>__iter__()</code> O(n)"},{"location":"structures/stack/#space-complexity","title":"Space Complexity","text":"<p>O(n) where n is the number of elements stored.</p>"},{"location":"structures/stack/#use-cases","title":"Use Cases","text":"<ul> <li>Expression Evaluation - Postfix/infix expression parsing</li> <li>Undo/Redo - Maintaining history in applications</li> <li>Backtracking - Depth-first search algorithms</li> <li>Function Call Stack - Managing function calls and local variables</li> <li>Syntax Parsing - Matching parentheses, brackets, etc.</li> </ul>"},{"location":"structures/stack/#example-balanced-parentheses","title":"Example: Balanced Parentheses","text":"<pre><code>def is_balanced(expression: str) -&gt; bool:\n    stack = Stack()\n    pairs = {'(': ')', '[': ']', '{': '}'}\n\n    for char in expression:\n        if char in pairs:\n            stack.push(char)\n        elif char in pairs.values():\n            if stack.is_empty():\n                return False\n            if pairs[stack.pop()] != char:\n                return False\n\n    return stack.is_empty()\n\nprint(is_balanced(\"((()))\"))  # True\nprint(is_balanced(\"((())\"))   # False\n</code></pre>"},{"location":"structures/stack/#example-postfix-evaluation","title":"Example: Postfix Evaluation","text":"<pre><code>def evaluate_postfix(expression: str) -&gt; int:\n    stack = Stack()\n\n    for token in expression.split():\n        if token.isdigit():\n            stack.push(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                stack.push(a + b)\n            elif token == '-':\n                stack.push(a - b)\n            elif token == '*':\n                stack.push(a * b)\n            elif token == '/':\n                stack.push(a // b)\n\n    return stack.pop()\n\nresult = evaluate_postfix(\"3 4 + 2 *\")  # (3+4)*2 = 14\n</code></pre>"}]}